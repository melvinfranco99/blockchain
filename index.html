<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mel Blockchain (Responsive)</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #9ca3af;
            --text: #f3f4f6;
            --accent: #22d3ee;
            --ok: #10b981;
            --warn: #f59e0b;
            --bad: #ef4444;
            --card: #0b1220;
            --pairW: 640px
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, #0b1220, #0f172a 20%, #0b1220 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale
        }

        header {
            position: sticky;
            top: 0;
            background: rgba(11, 18, 32, .6);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid #1f2937;
            z-index: 5
        }

        header .wrap {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px 16px;
            flex-wrap: wrap
        }

        h1 {
            font-size: clamp(18px, 4vw, 22px);
            margin: 0;
            letter-spacing: .3px
        }

        .tag {
            font-size: 12px;
            color: var(--muted);
            opacity: .9;
            flex: 1 1 100%
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px 12px
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            gap: 16px
        }

        section {
            grid-column: span 12;
            background: linear-gradient(180deg, #0d1526, #0a0f1c);
            border: 1px solid #1f2937;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, .35)
        }

        .card {
            padding: 16px 14px
        }

        section h2 {
            margin: 0 0 8px;
            font-size: clamp(16px, 4vw, 18px)
        }

        section p {
            color: var(--muted);
            margin: 4px 0 10px
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        input,
        select,
        textarea,
        button {
            border-radius: 12px;
            border: 1px solid #334155;
            background: #0f172a;
            color: var(--text);
            padding: 10px 12px;
            font-size: 14px
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: 2px solid #334155
        }

        button {
            cursor: pointer;
            background: #0f172a;
            touch-action: manipulation
        }

        button.primary {
            background: linear-gradient(180deg, #0ea5e9, #06b6d4);
            border: none;
            color: #002b36;
            font-weight: 700
        }

        button.good {
            background: linear-gradient(180deg, #34d399, #10b981);
            border: none;
            color: #052e1a;
            font-weight: 700
        }

        button.warn {
            background: linear-gradient(180deg, #fbbf24, #f59e0b);
            border: none;
            color: #3b2000;
            font-weight: 700
        }

        button.bad {
            background: linear-gradient(180deg, #f87171, #ef4444);
            border: none;
            color: #3a0b0b;
            font-weight: 700
        }

        code,
        pre {
            background: #0b1324;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 10px 12px
        }

        pre {
            white-space: pre-wrap;
            word-break: break-word;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.35
        }

        .kpi {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .pill {
            border: 1px solid #273449;
            background: #0b1220;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted)
        }

        .list {
            display: grid;
            gap: 10px
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
        }

        details {
            background: #0b1324;
            border: 1px solid #223046;
            border-radius: 10px;
            padding: 10px 12px
        }

        summary {
            cursor: pointer
        }

        .cols-2 {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px
        }

        .cols-3 {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 12px
        }

        .muted {
            color: var(--muted)
        }

        .hr {
            height: 1px;
            background: #1f2937;
            margin: 12px 0
        }

        .small {
            font-size: 12px
        }

        .node {
            border: 1px solid #223046;
            border-radius: 12px;
            padding: 10px;
            background: #0c1528
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid #2b3d5c;
            background: #0e1830;
            font-size: 11px;
            color: #cbd5e1
        }

        .scroll {
            max-height: 220px;
            overflow: auto
        }

        .pair-valid {
            border-color: var(--ok) !important;
            box-shadow: 0 10px 35px rgba(16, 185, 129, .25) !important;
            background: linear-gradient(180deg, #0f1f19, #0a1512) !important
        }

        .pair-invalid {
            border-color: var(--bad) !important;
            box-shadow: 0 10px 35px rgba(239, 68, 68, .25) !important;
            background: linear-gradient(180deg, #1f0f12, #150a0c) !important
        }

        .badge.badge-ok {
            border-color: var(--ok) !important;
            background: rgba(16, 185, 129, .15) !important;
            color: #d1fae5 !important
        }

        .badge.badge-bad {
            border-color: var(--bad) !important;
            background: rgba(239, 68, 68, .15) !important;
            color: #fee2e2 !important
        }

        .pairs-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fill, minmax(var(--pairW), 1fr));
            overflow: auto;
            padding-bottom: 6px
        }

        .pair-col {
            min-width: 0
        }

        @media (max-width:1024px) {
            :root {
                --pairW: 520px
            }
        }

        @media (max-width:768px) {
            :root {
                --pairW: min(100%, 360px)
            }

            .card {
                padding: 14px 12px
            }

            .row {
                flex-direction: column;
                align-items: stretch
            }

            input,
            select,
            textarea,
            button {
                width: 100%
            }

            .cols-2,
            .cols-3 {
                grid-template-columns: 1fr
            }

            .pairs-grid {
                grid-template-columns: 1fr
            }

            #btn-zoom-in,
            #btn-zoom-out,
            #zoom-label {
                display: none
            }

            pre {
                font-size: 12px
            }
        }

        @media (max-width:380px) {
            :root {
                --pairW: 300px
            }

            h1 {
                font-size: 18px
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="wrap">
            <h1>üß± Mel Blockchain</h1>
            <span class="tag">Secciones: Hash ‚Ä¢ Bloque ‚Ä¢ Blockchain ‚Ä¢ Coinbase</span>
        </div>
    </header>
    <main>
        <div class="grid">

            <!-- 1) HASH -->
            <section id="sec-hash" class="card">
                <h2>1) Hash</h2>
                <p>Escribe cualquier texto y calcula su <strong>SHA-256</strong>. Un cambio m√≠nimo cambia por completo
                    el hash.</p>
                <div class="row" style="gap:12px">
                    <input id="hash-input" placeholder="Texto a hashear" />
                    <button id="btn-hash" class="primary">Calcular SHA-256</button>
                </div>
                <div class="hr"></div>
                <div class="list">
                    <div class="row kpi">
                        <span class="pill">Algoritmo: SHA-256</span>
                        <span class="pill" id="secure-origin">Contexto: comprobando‚Ä¶</span>
                    </div>
                    <label class="small muted">Hash (hex):</label>
                    <pre id="hash-output" class="mono"></pre>
                </div>
            </section>

            <!-- 2) BLOQUE (POW) -->
            <section id="sec-bloque" class="card">
                <h2>2) Bloque</h2>
                <p>Juega con un bloque y haz <em>miner√≠a</em> (Proof-of-Work): busca un <code>nonce</code> tal que el
                    hash empiece con <code>0</code> repetido <em>difficulty</em> veces.</p>
                <div class="cols-2">
                    <div class="list">
                        <label>Datos (JSON libre)</label>
                        <textarea id="blk-data" rows="6"></textarea>
                        <div class="cols-3">
                            <div><label class="small muted">√çndice</label><input id="blk-index" type="number"
                                    value="1" /></div>
                            <div><label class="small muted">Prev. Hash</label><input id="blk-prev"
                                    value="0000000000000000000000000000000000000000000000000000000000000000" /></div>
                            <div><label class="small muted">Dificultad</label><input id="blk-diff" type="number" min="1"
                                    max="64" value="3" /></div>
                        </div>
                        <div class="row">
                            <button id="btn-mine" class="good">Minar</button>
                            <button id="btn-stop" class="bad">Parar</button>
                        </div>
                    </div>
                    <div class="list">
                        <label class="small muted">Nonce</label><input id="blk-nonce" type="number" value="0" />
                        <label class="small muted">Timestamp</label><input id="blk-time" />
                        <label class="small muted">Hash</label>
                        <pre id="blk-hash" class="mono"></pre>
                        <div class="row kpi">
                            <span class="badge" id="mine-status">‚ùå No Minado</span>
                            <div id="mining-indicator" class="row small"
                                style="display:none;align-items:center;gap:8px">
                                <svg width="18" height="18" viewBox="0 0 50 50" aria-hidden="true">
                                    <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="6"
                                        opacity="0.25" />
                                    <path fill="currentColor" d="M25 5a20 20 0 0 1 20 20h-6a14 14 0 0 0-14-14V5z">
                                        <animateTransform attributeName="transform" type="rotate" from="0 25 25"
                                            to="360 25 25" dur="0.9s" repeatCount="indefinite" />
                                    </path>
                                </svg>
                                <span>Minando‚Ä¶</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 3) BLOCKCHAIN (por pares) -->
            <section id="sec-chain" class="card">
                <h2>3) Blockchain descentralizada</h2>
                <p>Crea bloques en <strong>Par A</strong> y pulsa <em>A√±adir Par</em> para clonar el par anterior (Par
                    B, Par C, ‚Ä¶). Una vez copiado, cada par es completamente independiente.</p>
                <div class="row" style="align-items:center;gap:8px">
                    <button id="btn-pair-add" class="primary">A√±adir Par</button>
                    <div class="row" style="margin-left:auto;align-items:center;gap:6px">
                        <button id="btn-zoom-out" title="Desampliar"
                            style="width:36px;padding:6px 0;font-weight:700">‚àí</button>
                        <span class="pill" id="zoom-label">100%</span>
                        <button id="btn-zoom-in" title="Ampliar"
                            style="width:36px;padding:6px 0;font-weight:700">+</button>
                    </div>
                </div>
                <div class="hr"></div>
                <div id="pairs-container" class="list pairs-grid"></div>
            </section>

            <!-- 4) COINBASE -->
            <section id="sec-coinbase4" class="card">
                <h2>4) Coinbase</h2>
                <p>A√±ade transacciones (emisor, receptor, cantidad) y mina bloques. Cada bloque incluye una
                    <em>coinbase</em> de 50 BTC al minero desde <code>0x000‚Ä¶000</code>. La g√©nesis de esta secci√≥n
                    entrega saldo inicial a <strong>Alice</strong>.
                </p>
                <div class="row" style="gap:12px;margin-bottom:8px">
                    <label class="small muted">Recompensa por bloque</label>
                    <input id="cb-reward" type="number" value="50" />
                    <div class="pill">Dificultad fija: 3</div>
                </div>
                <div class="cols-3">
                    <!-- ORDEN NUEVO: 1) MINAR 2) CREAR TX 3) BALANCES -->
                    <div class="node" id="cb-box-mine">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Minar bloque</strong><span class="badge small">‚õèÔ∏è</span>
                        </div>
                        <div class="list">
                            <label class="small muted">Minero (cobra la coinbase)</label><input id="cb-miner"
                                placeholder="TuNombre" />
                            <button id="cb-btn-mine" class="good">Minar (coinbase + mempool)</button>
                            <div id="cb-mine-status" class="small muted"></div>
                            <details>
                                <summary>√öltimo bloque</summary>
                                <pre id="cb-lastblock" class="mono small"></pre>
                            </details>
                        </div>
                    </div>

                    <div class="node" id="cb-box-create-tx">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Crear transacci√≥n</strong><span class="badge small">Mempool</span>
                        </div>
                        <div class="list">
                            <label class="small muted">Emisor</label><input id="cb-from" placeholder="Alice"
                                value="Alice" />
                            <label class="small muted">Receptor</label><input id="cb-to" placeholder="Bob"
                                value="Bob" />
                            <label class="small muted">Cantidad (BTC)</label><input id="cb-amount" type="number" min="0"
                                step="1" value="10" />
                            <button id="cb-btn-add" class="primary">A√±adir TX</button>
                            <div class="hr"></div>
                            <div class="scroll">
                                <pre id="cb-mempool" class="mono small"></pre>
                            </div>
                        </div>
                    </div>

                    <div class="node" id="cb-box-balances">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Balances</strong><span class="badge small">Œ£</span>
                        </div>
                        <div class="list">
                            <button id="cb-btn-balances">Calcular balances</button>
                            <div class="scroll">
                                <pre id="cb-balances" class="mono small"></pre>
                            </div>
                            <div class="small muted">Nota: se muestran balances confirmados y tambi√©n una proyecci√≥n que
                                incluye las transacciones en el mempool.</div>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </main>

    <script>
        // -------- Utilidades --------
        const enc = new TextEncoder();
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const hex = (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        const ZERO_ADDR = '0x' + '0'.repeat(40);
        async function sha256(str) { const data = enc.encode(str); const digest = await crypto.subtle.digest('SHA-256', data); return hex(digest) }
        function nowISO() { return new Date().toISOString() }
        function el(id) { return document.getElementById(id) }

        // -------- Modelo de datos --------
        class Block {
            constructor({ index, timestamp, transactions, previousHash, nonce, difficulty }) {
                this.index = index; this.timestamp = timestamp || nowISO(); this.transactions = transactions || [];
                this.previousHash = previousHash || '0'.repeat(64); this.nonce = nonce || 0; this.difficulty = difficulty || 2; this.hash = ''
            }
            canonical() { return JSON.stringify({ index: this.index, timestamp: this.timestamp, transactions: this.transactions, previousHash: this.previousHash, nonce: this.nonce, difficulty: this.difficulty }) }
            async computeHash() { this.hash = await sha256(this.canonical()); return this.hash }
            async mine() {
                let target = '0'.repeat(this.difficulty); let attempts = 0;
                while (true) { attempts++; this.hash = await sha256(this.canonical()); if (this.hash.startsWith(target)) return { hash: this.hash, attempts }; this.nonce++; if (attempts % 300 === 0) await sleep(0) }
            }
        }
        class Blockchain {
            constructor({ difficulty = 3, reward = 50, premine = null } = {}) { this.chain = []; this.difficulty = difficulty; this.mempool = []; this.reward = reward; this.premine = premine; this.ready = this.createGenesis() }
            async createGenesis() {
                const txs = []; if (this.premine && this.premine.amount > 0) { txs.push({ coinbase: true, from: ZERO_ADDR, to: this.premine.to, amount: this.premine.amount }) }
                else { txs.push({ coinbase: true, from: ZERO_ADDR, to: 'satoshi', amount: 0 }) }
                const g = new Block({ index: 0, timestamp: nowISO(), transactions: txs, previousHash: '0'.repeat(64), nonce: 0, difficulty: 1 });
                await g.computeHash(); this.chain = [g]
            }
            get last() { return this.chain[this.chain.length - 1] }
            balances() { const bal = {}; for (const b of this.chain) { for (const tx of b.transactions || []) { if (tx.coinbase) { bal[tx.to] = (bal[tx.to] || 0) + Number(tx.amount || 0) } else { const a = Number(tx.amount || 0); if (tx.from) bal[tx.from] = (bal[tx.from] || 0) - a; if (tx.to) bal[tx.to] = (bal[tx.to] || 0) + a } } } return bal }
            // NUEVO: saldo efectivo considerando el mempool (para evitar sobre-gasto al crear TX)
            effectiveBalanceOf(addr) {
                addr = String(addr || '').trim();
                const bal = this.balances();
                let base = bal[addr] || 0;
                for (const tx of this.mempool) {
                    if (!tx.coinbase && String(tx.from || '').trim() === addr) {
                        base -= Number(tx.amount || 0);
                    }
                }
                return base;
            }
            canSpend(addr, amount) { return this.effectiveBalanceOf(addr) >= Number(amount || 0) }
            _validateBundle(allTxs) {
                const bal = this.balances(); for (const tx of allTxs) {
                    if (tx.coinbase) { bal[tx.to] = (bal[tx.to] || 0) + Number(tx.amount || 0); continue }
                    const from = String(tx.from || '').trim(); const to = String(tx.to || '').trim(); const amt = Number(tx.amount || 0);
                    if (!from || !to || !(amt > 0)) throw new Error('TX inv√°lida'); if ((bal[from] || 0) < amt) throw new Error(`Saldo insuficiente en ${from}`); bal[from] -= amt; bal[to] = (bal[to] || 0) + amt
                }
            }
            // NUEVO: proyecci√≥n de balances incluyendo mempool (para mostrar en UI)
            projectedBalances() {
                const bal = this.balances();
                for (const tx of this.mempool) {
                    if (tx.coinbase) continue;
                    const from = String(tx.from || '').trim(); const to = String(tx.to || '').trim(); const amt = Number(tx.amount || 0);
                    if (!from || !to || !(amt > 0)) continue;
                    if ((bal[from] || 0) >= amt) { bal[from] = (bal[from] || 0) - amt; bal[to] = (bal[to] || 0) + amt; }
                }
                return bal;
            }
            async addBlockFrom({ transactions, miner }) {
                const mem = [...(transactions || this.mempool)]; mem.unshift({ coinbase: true, from: ZERO_ADDR, to: miner, amount: this.reward }); this._validateBundle(mem);
                const b = new Block({ index: this.last.index + 1, timestamp: nowISO(), transactions: mem, previousHash: this.last.hash, nonce: 0, difficulty: this.difficulty });
                await b.mine(); this.chain.push(b); this.mempool = []; return b
            }
            async addExternalBlock(b) { const prev = this.last; if (b.previousHash !== prev.hash) return false; const temp = new Block(b); const h = await sha256(temp.canonical()); if (h !== b.hash) return false; if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false; this.chain.push(b); return true }
            async isValid() { for (let i = 1; i < this.chain.length; i++) { const a = this.chain[i - 1], b = this.chain[i]; const t = new Block(b); const h = await sha256(t.canonical()); if (b.previousHash !== a.hash) return false; if (h !== b.hash) return false; if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false } return true }
        }

        // -------- Estado global --------
        let chain = new Blockchain({ difficulty: 3, reward: 50 });
        const nodes = [new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 })];

        // -------- UI: Hash --------
        function updateSecure() { el('secure-origin').textContent = 'Contexto: ' + (window.isSecureContext ? 'seguro (OK para crypto.subtle)' : 'no seguro (sirve la p√°gina via http://localhost)') }
        updateSecure();
        el('btn-hash').addEventListener('click', async () => {
            const text = el('hash-input').value || ''; el('hash-output').textContent = 'calculando‚Ä¶';
            try { const h = await sha256(text); el('hash-output').textContent = h }
            catch (e) { el('hash-output').textContent = 'Error: ' + e.message + '\nSugerencia: abre mediante http://localhost (no file://).' }
        });

        // -------- UI: Bloque --------
        function getDifficulty() { const raw = el('blk-diff').value; let v = parseInt(raw, 10); if (!Number.isFinite(v)) v = 1; v = Math.max(1, Math.min(64, v)); if (String(v) !== String(raw)) el('blk-diff').value = v; return v }
        function uiCanonicalFromInputs() { return JSON.stringify({ index: Number(el('blk-index').value || 1), timestamp: el('blk-time').value || nowISO(), data: el('blk-data').value ?? '', previousHash: el('blk-prev').value || '0'.repeat(64), nonce: Number(el('blk-nonce').value || 0) }) }
        function setVisual(mined) { const s = el('mine-status'); s.textContent = mined ? '‚úÖ Minado' : '‚ùå No Minado'; s.style.background = mined ? 'var(--ok)' : 'var(--bad)'; s.style.borderColor = mined ? 'var(--ok)' : 'var(--bad)'; s.style.color = '#fff'; const sec = el('sec-bloque'); if (mined) { sec.style.borderColor = 'var(--ok)'; sec.style.boxShadow = '0 10px 35px rgba(16,185,129,0.25)'; sec.style.background = 'linear-gradient(180deg,#0f1f19,#0a1512)' } else { sec.style.borderColor = 'var(--bad)'; sec.style.boxShadow = '0 10px 35px rgba(239,68,68,0.25)'; sec.style.background = 'linear-gradient(180deg,#1f0f12,#150a0c)' } }
        function showMining(on) { const d = el('mining-indicator'); if (!d) return; d.style.display = on ? 'flex' : 'none' }
        function meetsDifficulty(hash, d) { const dd = Math.max(1, Math.min(64, Number(d) || 1)); const need = '0'.repeat(dd); return !!hash && hash.startsWith(need) }

        let hashCalcVersion = 0;
        async function recomputeHashAuto() { const myVersion = ++hashCalcVersion; const payload = uiCanonicalFromInputs(); el('blk-hash').textContent = 'calculando‚Ä¶'; const newHash = await sha256(payload); if (myVersion !== hashCalcVersion) return; el('blk-hash').textContent = newHash; setVisual(meetsDifficulty(newHash, getDifficulty())) }
        ['blk-data', 'blk-index', 'blk-prev', 'blk-nonce', 'blk-time'].forEach(id => { const n = el(id); if (!n) return; n.addEventListener('input', () => { recomputeHashAuto() }) });
        if (!el('blk-time').value) el('blk-time').value = nowISO(); setVisual(false); recomputeHashAuto();

        let stopMining = false;
        el('btn-stop').addEventListener('click', () => { stopMining = true; showMining(false) });
        el('btn-mine').addEventListener('click', async () => {
            stopMining = false; showMining(true);
            const idx = Number(el('blk-index').value || 1);
            const ts = el('blk-time').value || nowISO();
            const prev = el('blk-prev').value || '0'.repeat(64);
            let nonce = 0; el('blk-nonce').value = 0;
            const d = getDifficulty(); const target = '0'.repeat(d);
            const dataRaw = el('blk-data').value ?? ''; let attempts = 0;
            while (!stopMining) {
                const payload = JSON.stringify({ index: idx, timestamp: ts, data: dataRaw, previousHash: prev, nonce });
                const h = await sha256(payload);
                if (h.startsWith(target)) { el('blk-nonce').value = nonce; el('blk-hash').textContent = h; setVisual(true); showMining(false); return }
                nonce++; attempts++; if (attempts % 500 === 0) await sleep(0)
            }
            showMining(false); recomputeHashAuto();
        });

        // -------- UI: Blockchain por pares (secci√≥n 3) --------
        (() => {
            const ZERO64 = '0'.repeat(64);
            const DEFAULT_TS = '2000-01-01T00:00:00.000Z';
            const pairsWrap = el('pairs-container');
            const btnAddPair = el('btn-pair-add');

            let zoom = 1; const ZMIN = .2, ZMAX = 1.5, ZSTEP = .1;
            function clamp(n, a, b) { return Math.min(b, Math.max(a, n)) }
            function applyZoom() { if (window.matchMedia('(max-width: 768px)').matches) { zoom = 1 } const label = el('zoom-label'); if (label) label.textContent = Math.round(zoom * 100) + '%'; pairsWrap.style.zoom = String(zoom) }
            el('btn-zoom-in')?.addEventListener('click', () => { zoom = clamp(+(zoom + ZSTEP).toFixed(2), ZMIN, ZMAX); applyZoom() });
            el('btn-zoom-out')?.addEventListener('click', () => { zoom = clamp(+(zoom - ZSTEP).toFixed(2), ZMIN, ZMAX); applyZoom() }); applyZoom();
            function letters(n) { n = Number(n) || 0; let s = ''; n++; while (n > 0) { const r = (n - 1) % 26; s = String.fromCharCode(65 + r) + s; n = Math.floor((n - 1) / 26) } return s }

            function makeBlockCard({ index, prevHash, defaultDifficulty, initialTimestamp, snapshot } = {}) {
                const wrap = document.createElement('div'); wrap.className = 'node'; wrap.style.padding = '12px';
                wrap.innerHTML = `
        <div class="cols-2">
          <div class="list">
            <label>Datos (JSON libre)</label>
            <textarea class="data" rows="6" style="display:none"></textarea>
            <div class="cols-3">
              <div><label class="small muted">√çndice</label><input class="index" type="number" /></div>
              <div><label class="small muted">Prev. Hash</label><input class="prev" /></div>
              <div><label class="small muted">Dificultad</label><input class="diff" type="number" min="1" max="64" /></div>
            </div>
            <div class="row"><button class="mine good">Minar</button><button class="stop bad">Parar</button></div>
          </div>
          <div class="list">
            <label class="small muted">Nonce</label><input class="nonce" type="number" value="0" />
            <label class="small muted">Timestamp</label><input class="time" />
            <label class="small muted">Hash</label><pre class="hash mono"></pre>
            <div class="row kpi">
              <span class="badge status">‚ùå No Minado</span>
              <div class="row small indicator" style="display:none;align-items:center;gap:8px">
                <svg width="18" height="18" viewBox="0 0 50 50" aria-hidden="true">
                  <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="6" opacity="0.25" />
                  <path fill="currentColor" d="M25 5a20 20 0 0 1 20 20h-6a14 14 0 0 0-14-14V5z">
                    <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.9s" repeatCount="indefinite" />
                  </path>
                </svg>
                <span>Minando‚Ä¶</span>
              </div>
            </div>
          </div>
        </div>`;
                const refs = {
                    data: wrap.querySelector('.data'), index: wrap.querySelector('.index'), prev: wrap.querySelector('.prev'),
                    diff: wrap.querySelector('.diff'), mine: wrap.querySelector('.mine'), stop: wrap.querySelector('.stop'),
                    nonce: wrap.querySelector('.nonce'), time: wrap.querySelector('.time'), hash: wrap.querySelector('.hash'),
                    indicator: wrap.querySelector('.indicator'), status: wrap.querySelector('.status'),
                };

                // Campos estructurados (sin mostrar "Datos (JSON)")
                const leftList = wrap.querySelector('.cols-2').children[0];
                const dataArea = refs.data;
                const lblFrom = document.createElement('label'); lblFrom.className = 'small muted'; lblFrom.textContent = 'Emisor';
                const inFrom = document.createElement('input'); inFrom.className = 'from'; inFrom.placeholder = 'Alice';
                const lblTo = document.createElement('label'); lblTo.className = 'small muted'; lblTo.textContent = 'Receptor';
                const inTo = document.createElement('input'); inTo.className = 'to'; inTo.placeholder = 'Bob';
                const lblAmt = document.createElement('label'); lblAmt.className = 'small muted'; lblAmt.textContent = 'Cantidad (BTC)';
                const inAmt = document.createElement('input'); inAmt.className = 'amount'; inAmt.type = 'number'; inAmt.min = '0'; inAmt.step = '0.00000001'; inAmt.value = '0';

                // Insertar campos visibles
                leftList.insertBefore(lblFrom, dataArea);
                leftList.insertBefore(inFrom, dataArea);
                leftList.insertBefore(lblTo, dataArea);
                leftList.insertBefore(inTo, dataArea);
                leftList.insertBefore(lblAmt, dataArea);
                leftList.insertBefore(inAmt, dataArea);

                // Bot√≥n eliminar solo para el √∫ltimo bloque del par
                const delBtn = document.createElement('button'); delBtn.className = 'bad delete'; delBtn.textContent = 'Eliminar bloque'; delBtn.style.display = 'none'; leftList.appendChild(delBtn);

                // Refs nuevas
                refs.from = inFrom; refs.to = inTo; refs.amount = inAmt; refs.del = delBtn;

                function syncFromFields() {
                    const obj = {
                        from: (refs.from.value || ''),
                        to: (refs.to.value || ''),
                        amount: Number(refs.amount.value || 0)
                    };
                    if (dataArea) dataArea.value = JSON.stringify(obj);
                }

                function syncFieldsFromData() {
                    try { const obj = JSON.parse(dataArea?.value || '{}'); refs.from.value = obj.from || ''; refs.to.value = obj.to || ''; refs.amount.value = (obj.amount != null) ? String(obj.amount) : '0' }
                    catch { }
                }
                function setCardVisual(mined) {
                    refs.status.textContent = mined ? '‚úÖ Minado' : '‚ùå No Minado';
                    refs.status.style.background = mined ? 'var(--ok)' : 'var(--bad)';
                    refs.status.style.borderColor = mined ? 'var(--ok)' : 'var(--bad)'; refs.status.style.color = '#fff';
                    if (mined) { wrap.style.borderColor = 'var(--ok)'; wrap.style.boxShadow = '0 10px 35px rgba(16,185,129,0.25)'; wrap.style.background = 'linear-gradient(180deg,#0f1f19,#0a1512)' }
                    else { wrap.style.borderColor = 'var(--bad)'; wrap.style.boxShadow = '0 10px 35px rgba(239,68,68,0.25)'; wrap.style.background = 'linear-gradient(180deg,#1f0f12,#150a0c)' }
                }
                function parseDataForHash() {
                    try { return JSON.parse(refs.data.value || '{}') } catch { return refs.data.value || '' }
                }
                let localVersion = 0, stopMining = false; let notify = async () => { };
                function localGetDifficulty() { let v = parseInt(refs.diff.value, 10); if (!Number.isFinite(v)) v = 1; v = Math.max(1, Math.min(64, v)); if (String(v) !== String(refs.diff.value)) refs.diff.value = v; return v }
                function localPayload() {
                    const dataObj = parseDataForHash(); // <‚Äî ¬°clave! usar objeto, no string
                    return JSON.stringify({ index: Number(refs.index.value || 1), timestamp: refs.time.value, data: dataObj, previousHash: refs.prev.value || ZERO64, nonce: Number(refs.nonce.value || 0) })
                }
                async function recompute() {
                    const myVer = ++localVersion; refs.hash.textContent = 'calculando‚Ä¶';
                    const h = await sha256(localPayload()); if (myVer !== localVersion) return h;
                    refs.hash.textContent = h; setCardVisual(meetsDifficulty(h, localGetDifficulty())); return h
                }
                function showMining(show) { refs.indicator.style.display = show ? 'flex' : 'none' }

                if (snapshot) {
                    refs.index.value = Number(snapshot.index); refs.prev.value = snapshot.prev || ZERO64; refs.diff.value = Number(snapshot.diff ?? 3);
                    refs.nonce.value = Number(snapshot.nonce ?? 0); refs.time.value = snapshot.time || DEFAULT_TS; refs.data.value = snapshot.data ?? '';
                    refs.hash.textContent = snapshot.hash || ''; syncFieldsFromData();
                    const mined = snapshot.hash ? meetsDifficulty(snapshot.hash, Number(snapshot.diff ?? 1)) : false; setCardVisual(mined);
                } else {
                    refs.index.value = Number(index ?? 1); refs.prev.value = prevHash || ZERO64; refs.diff.value = Number(defaultDifficulty ?? 3);
                    refs.nonce.value = 0; refs.time.value = initialTimestamp || DEFAULT_TS; syncFromFields(); setCardVisual(false); recompute();
                }

                [refs.data, refs.index, refs.prev, refs.nonce, refs.time].forEach(n => n.addEventListener('input', async () => { await recompute(); await notify() }));
                refs.from.addEventListener('input', async () => { syncFromFields(); await recompute(); await notify() });
                refs.to.addEventListener('input', async () => { syncFromFields(); await recompute(); await notify() });
                refs.amount.addEventListener('input', async () => { syncFromFields(); await recompute(); await notify() });
                refs.diff.addEventListener('input', async () => { await recompute(); await notify() });

                refs.stop.addEventListener('click', () => { stopMining = true; showMining(false) });
                refs.mine.addEventListener('click', async () => {
                    stopMining = false; showMining(true);
                    const idx = Number(refs.index.value || 1);
                    const ts = refs.time.value || DEFAULT_TS;
                    const prev = refs.prev.value || ZERO64;
                    let nonce = 0; refs.nonce.value = 0;
                    const d = localGetDifficulty(); const target = '0'.repeat(d);
                    const tx = {
                        from: (refs.from.value || ''),
                        to: (refs.to.value || ''),
                        amount: Number(refs.amount.value || 0)
                    };

                    let attempts = 0;
                    while (!stopMining) {
                        const payload = JSON.stringify({ index: idx, timestamp: ts, data: tx, previousHash: prev, nonce });
                        const h = await sha256(payload);
                        if (h.startsWith(target)) { refs.nonce.value = nonce; refs.hash.textContent = h; setCardVisual(true); showMining(false); await notify(); return }
                        nonce++; attempts++; if (attempts % 500 === 0) await sleep(0)
                    }
                    showMining(false); await recompute(); await notify();
                });

                return { wrap, refs, recompute, get hash() { return (refs.hash.textContent || '').trim() }, setNotify(fn) { notify = fn } };
            }

            const pairs = [];
            function isCardMined(card) { const diff = Number(card.refs.diff.value || 1); const h = card.hash || ''; return meetsDifficulty(h, diff) }

            // Consenso sencillo (>50%)
            function evaluateConsensus() {
                const total = pairs.length; if (total < 3) { for (const p of pairs) applyPairClass(p, false, false); return }
                const groups = new Map(); const keyOf = (h, hash) => `${h}|${hash}`;
                const candidateSet = new Set();
                for (const p of pairs) {
                    const height = p.cards.length; if (height === 0) continue;
                    let allMined = true, chainOk = true;
                    for (let i = 0; i < height && allMined && chainOk; i++) {
                        const c = p.cards[i]; if (!isCardMined(c)) { allMined = false; break }
                        if (i > 0) { const prevH = p.cards[i - 1].hash || ''; const prevField = p.cards[i].refs.prev.value || ''; if (prevField !== prevH) { chainOk = false; break } }
                    }
                    if (!allMined || !chainOk) continue;
                    const lastHash = p.cards[height - 1].hash || ''; if (!lastHash) continue;
                    const k = keyOf(height, lastHash); if (!groups.has(k)) groups.set(k, { members: [] }); groups.get(k).members.push(p); candidateSet.add(p);
                }
                let best = null, bestCount = 0; for (const [, g] of groups) { if (g.members.length > bestCount) { bestCount = g.members.length; best = g } }
                if (best && bestCount > total / 2) { const valid = new Set(best.members); for (const p of pairs) { applyPairClass(p, !valid.has(p), valid.has(p)) } }
                else { for (const p of pairs) applyPairClass(p, true, false) }
            }
            function setPairBadge(pair, { state, text }) { const b = pair.refs.badge; if (!b) return; b.classList.remove('badge-ok', 'badge-bad'); if (state === 'invalid') { b.textContent = text || '‚ùå Inv√°lido'; b.classList.add('badge-bad') } else if (state === 'valid') { b.textContent = text || '‚úÖ V√°lido'; b.classList.add('badge-ok') } else { b.textContent = text || '‚Äî' } }
            function applyPairClass(pair, invalid, highlightValid) {
                pair.col.classList.toggle('pair-invalid', !!invalid);
                pair.col.classList.toggle('pair-valid', !!highlightValid && !invalid);
                if (invalid) setPairBadge(pair, { state: 'invalid' }); else if (highlightValid) setPairBadge(pair, { state: 'valid' }); else setPairBadge(pair, { state: 'neutral' });
            }

            async function makePair(fromPair = null) {
                const idx = pairs.length; const name = 'Par ' + letters(idx);
                const col = document.createElement('div'); col.className = 'node pair-col'; col.style.padding = '12px';
                col.innerHTML = `
        <div class="row" style="justify-content:space-between;align-items:center">
          <div class="row" style="gap:8px;align-items:center">
            <strong>${name}</strong><span class="badge small pair-badge">‚Äî</span>
          </div>
          <button class="primary add-block">A√±adir bloque</button><button class="bad del-pair">Eliminar par</button>
        </div>
        <div class="hr"></div>
        <div class="list blocks"></div>`;
                const refs = { addBlock: col.querySelector('.add-block'), blocks: col.querySelector('.blocks'), badge: col.querySelector('.pair-badge'), delPair: col.querySelector('.del-pair') };
                const cards = [];
                function updateDeleteButtons() {
                    cards.forEach((c, i) => {
                        if (!c.refs.del) return;
                        if (i === cards.length - 1) { c.refs.del.style.display = 'inline-block'; c.refs.del.onclick = async () => { const idx = cards.indexOf(c); if (idx !== cards.length - 1) return; c.wrap.remove(); cards.splice(idx, 1); await cascadeFrom(idx); evaluateConsensus(); updateDeleteButtons() } }
                        else { c.refs.del.style.display = 'none'; c.refs.del.onclick = null }
                    });
                }
                async function cascadeFrom(startIdx) {
                    for (let i = startIdx; i < cards.length; i++) { const prevH = cards[i - 1].hash || ZERO64; cards[i].refs.prev.value = prevH; await cards[i].recompute() }
                }
                function connectNotifies() {
                    cards.forEach(c => c.setNotify(async () => { const pos = cards.indexOf(c); await cascadeFrom(pos + 1); evaluateConsensus() }));
                }
                refs.addBlock.addEventListener('click', async () => {
                    let prevHash = ZERO64; if (cards.length > 0) { await cards[cards.length - 1].recompute(); prevHash = cards[cards.length - 1].hash || ZERO64 }
                    const defaultDiff = Number(el('blk-diff')?.value || 3);
                    const card = makeBlockCard({ index: cards.length + 1, prevHash, defaultDifficulty: defaultDiff, initialTimestamp: DEFAULT_TS });
                    refs.blocks.appendChild(card.wrap); cards.push(card); connectNotifies(); evaluateConsensus(); updateDeleteButtons();
                });

                const pair = { name, col, refs, cards, cascadeFrom };

                refs.delPair.addEventListener('click', async () => { const i = pairs.indexOf(pair); if (i !== -1) { pairs.splice(i, 1); col.remove(); evaluateConsensus() } });
                pairs.push(pair); pairsWrap.appendChild(col); evaluateConsensus();

                if (fromPair && Array.isArray(fromPair.cards) && fromPair.cards.length) {
                    for (const src of fromPair.cards) {
                        const snap = { index: Number(src.refs.index.value), data: src.refs.data.value, prev: src.refs.prev.value, diff: Number(src.refs.diff.value), nonce: Number(src.refs.nonce.value), time: src.refs.time.value, hash: src.hash };
                        const card = makeBlockCard({ snapshot: snap }); refs.blocks.appendChild(card.wrap); cards.push(card); await card.recompute();
                    }
                    connectNotifies(); evaluateConsensus(); await new Promise(requestAnimationFrame); evaluateConsensus(); updateDeleteButtons();
                } else { evaluateConsensus(); updateDeleteButtons() }
                return pair;
            }

            btnAddPair.addEventListener('click', async () => { const last = pairs[pairs.length - 1] || null; await makePair(last || null) });
            (async () => { await makePair(null) })();
        })();

        // ---- Secci√≥n 4) Coinbase (mejorada) ----
        const cbChain = new Blockchain({ difficulty: 3, reward: 50, premine: { to: 'Alice', amount: 1_000_000 } });
        function cbRenderMempool() { el('cb-mempool').textContent = JSON.stringify(cbChain.mempool, null, 2) }
        function cbRenderBalances() {
            const confirmed = cbChain.balances();
            const projected = cbChain.projectedBalances();
            const keys = Array.from(new Set([...Object.keys(confirmed), ...Object.keys(projected)])).sort();
            const rows = keys.map(k => {
                const c = confirmed[k] || 0;
                const p = projected[k] || 0;
                return `${k}: ${c} (confirmadas) | ${p} (incl. mempool)`;
            });
            el('cb-balances').textContent = rows.join('\\n') || '(sin movimientos a√∫n)';
        }
        function cbRenderLastBlock() { const b = cbChain.last || null; el('cb-lastblock').textContent = b ? JSON.stringify({ index: b.index, ts: b.timestamp, txs: b.transactions, prev: b.previousHash.slice(0, 16) + '‚Ä¶', hash: b.hash }, null, 2) : '(sin bloques)' }
        el('cb-reward').addEventListener('input', () => { const v = Number(el('cb-reward').value || 50); cbChain.reward = v > 0 ? v : 50 });
        el('cb-btn-add').addEventListener('click', () => {
            const from = el('cb-from').value.trim(); const to = el('cb-to').value.trim(); const amt = Number(el('cb-amount').value || 0);
            if (!from || !to || !(amt > 0)) { alert('Completa emisor, receptor y cantidad > 0'); return }
            if (!cbChain.canSpend(from, amt)) { alert(`Saldo insuficiente en ${from}. Considera minar o reduce la cantidad. (Se tiene en cuenta el mempool)`); return }
            cbChain.mempool.push({ from, to, amount: amt }); cbRenderMempool(); cbRenderBalances();
        });
        el('cb-btn-mine').addEventListener('click', async () => {
            const miner = (el('cb-miner').value || '').trim() || 'miner'; el('cb-mine-status').textContent = 'Minando‚Ä¶';
            try { const b = await cbChain.addBlockFrom({ transactions: cbChain.mempool, miner }); el('cb-mine-status').textContent = `Bloque #${b.index} minado. ${cbChain.reward} BTC para ${miner}. Hash ${b.hash.slice(0, 12)}‚Ä¶` }
            catch (e) { el('cb-mine-status').textContent = 'Error: ' + e.message }
            cbRenderMempool(); cbRenderBalances(); cbRenderLastBlock();
        });
        el('cb-btn-balances').addEventListener('click', () => { cbRenderBalances() });
        (async () => { await cbChain.ready; cbRenderMempool(); cbRenderBalances(); cbRenderLastBlock() })();

        // -------- UI: TX (secci√≥n 5) --------
        function refreshNodeSelect() { const sel = el('tx-node'); if (!sel) return; sel.innerHTML = '';['Nodo 1', 'Nodo 2', 'Nodo 3'].forEach((lab, i) => { const o = document.createElement('option'); o.value = String(i); o.textContent = lab; sel.appendChild(o) }) }
        refreshNodeSelect();
        function renderMempool() { const n = nodes[Number(el('tx-node')?.value || 0)]; if (!n) return; el('mempool-view').textContent = JSON.stringify(n.mempool, null, 2) }
        function renderBalances() { const n = nodes[Number(el('tx-node')?.value || 0)]; if (!n) return; const bal = n.balances(); const rows = Object.keys(bal).sort().map(k => `${k}: ${bal[k]}`); el('balances-view').textContent = rows.join('\\n') || '(sin movimientos a√∫n)' }
        el('tx-node')?.addEventListener('change', () => { renderMempool(); renderBalances() });
        el('btn-tx-add')?.addEventListener('click', () => {
            const n = nodes[Number(el('tx-node').value || 0)];
            const from = el('tx-from').value.trim(); const to = el('tx-to').value.trim(); const amount = Number(el('tx-amount').value || 0);
            if (!to || amount <= 0) { alert('Completa destinatario y cantidad>0'); return }
            if (from && !n.canSpend(from, amount)) { alert('Saldo insuficiente en ' + from + ' (recuerda minar coinbase primero)'); return }
            n.mempool.push({ from, to, amount }); renderMempool();
        });
        el('btn-mine-mempool')?.addEventListener('click', async () => {
            const idx = Number(el('tx-node').value || 0); const n = nodes[idx];
            n.reward = Number(el('tx-reward').value) || 50;
            const miner = el('miner-addr').value.trim() || 'miner' + (idx + 1);
            el('mine-coinbase-status').textContent = 'Minando‚Ä¶';
            const b = await n.addBlockFrom({ transactions: n.mempool, miner });
            el('mine-coinbase-status').textContent = 'Bloque #' + b.index + ' minado. Hash ' + b.hash.slice(0, 12) + '‚Ä¶';
            renderMempool(); renderBalances();
        });
        el('btn-balances')?.addEventListener('click', () => { renderBalances() });
        Promise.all(nodes.map(n => n.ready)).then(() => { renderMempool(); renderBalances() });
    </script>
</body>

</html>