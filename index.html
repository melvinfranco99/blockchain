<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mini Blockchain Playground</title>
    <style>
        :root {
            --bg: #0f172a;
            /* slate-900 */
            --panel: #111827;
            /* gray-900 */
            --muted: #9ca3af;
            /* gray-400 */
            --text: #f3f4f6;
            /* gray-100 */
            --accent: #22d3ee;
            /* cyan-400 */
            --ok: #10b981;
            /* emerald-500 */
            --warn: #f59e0b;
            /* amber-500 */
            --bad: #ef4444;
            /* red-500 */
            --card: #0b1220;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, #0b1220, #0f172a 20%, #0b1220 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu;
        }

        header {
            position: sticky;
            top: 0;
            background: rgba(11, 18, 32, .6);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid #1f2937;
            z-index: 5
        }

        header .wrap {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 12px 16px
        }

        h1 {
            font-size: 20px;
            margin: 0;
            letter-spacing: .3px
        }

        .tag {
            font-size: 12px;
            color: var(--muted)
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            gap: 16px
        }

        section {
            grid-column: span 12;
            background: linear-gradient(180deg, #0d1526, #0a0f1c);
            border: 1px solid #1f2937;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, .35);
        }

        .card {
            padding: 18px 16px
        }

        section h2 {
            margin: 0 0 8px 0;
            font-size: 18px
        }

        section p {
            color: var(--muted);
            margin: 4px 0 10px 0
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        input,
        select,
        textarea,
        button {
            border-radius: 12px;
            border: 1px solid #334155;
            background: #0f172a;
            color: var(--text);
            padding: 10px 12px;
            font-size: 14px
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: 2px solid #334155
        }

        button {
            cursor: pointer;
            background: #0f172a
        }

        button.primary {
            background: linear-gradient(180deg, #0ea5e9, #06b6d4);
            border: none;
            color: #002b36;
            font-weight: 700
        }

        button.good {
            background: linear-gradient(180deg, #34d399, #10b981);
            border: none;
            color: #052e1a;
            font-weight: 700
        }

        button.warn {
            background: linear-gradient(180deg, #fbbf24, #f59e0b);
            border: none;
            color: #3b2000;
            font-weight: 700
        }

        button.bad {
            background: linear-gradient(180deg, #f87171, #ef4444);
            border: none;
            color: #3a0b0b;
            font-weight: 700
        }

        code,
        pre {
            background: #0b1324;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 10px 12px
        }

        pre {
            white-space: pre-wrap;
            word-break: break-word
        }

        .kpi {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .pill {
            border: 1px solid #273449;
            background: #0b1220;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted)
        }

        .list {
            display: grid;
            gap: 10px
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
        }

        details {
            background: #0b1324;
            border: 1px solid #223046;
            border-radius: 10px;
            padding: 10px 12px
        }

        summary {
            cursor: pointer
        }

        .cols-2 {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px
        }

        .cols-3 {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 12px
        }

        .muted {
            color: var(--muted)
        }

        .hr {
            height: 1px;
            background: #1f2937;
            margin: 12px 0
        }

        .small {
            font-size: 12px
        }

        .node {
            border: 1px solid #223046;
            border-radius: 12px;
            padding: 10px;
            background: #0c1528
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid #2b3d5c;
            background: #0e1830;
            font-size: 11px;
            color: #cbd5e1
        }

        .scroll {
            max-height: 220px;
            overflow: auto
        }
    </style>
</head>

<body>
    <header>
        <div class="wrap">
            <h1>üß± Mini Blockchain Playground</h1>
            <span class="tag">Secciones: Hash ‚Ä¢ Bloque ‚Ä¢ Blockchain ‚Ä¢ Distribuida ‚Ä¢ Coinbase</span>
        </div>
    </header>
    <main>
        <div class="grid">

            <!-- 1) HASH -->
            <section id="sec-hash" class="card">
                <h2>1) Hash</h2>
                <p>Escribe cualquier texto y calcula su <strong>SHA‚Äë256</strong>. Un cambio m√≠nimo cambia por completo
                    el hash.</p>
                <div class="row" style="gap:12px">
                    <input id="hash-input" placeholder="Texto a hashear" style="flex:1" />
                    <button id="btn-hash" class="primary">Calcular SHA‚Äë256</button>
                </div>
                <div class="hr"></div>
                <div class="list">
                    <div class="row kpi">
                        <span class="pill">Algoritmo: SHA‚Äë256</span>
                        <span class="pill" id="secure-origin">Contexto: comprobando‚Ä¶</span>
                    </div>
                    <label class="small muted">Hash (hex):</label>
                    <pre id="hash-output" class="mono"></pre>
                </div>
            </section>

            <!-- 2) BLOQUE (POW) -->
            <section id="sec-bloque" class="card">
                <h2>2) Bloque</h2>
                <p>Juega con un bloque y haz <em>miner√≠a</em> (Proof‚Äëof‚ÄëWork): busca un <code>nonce</code> tal que el
                    hash empiece con <code>0</code> repetido <em>difficulty</em> veces.</p>
                <div class="cols-2">
                    <div class="list">
                        <label>Datos (JSON libre)</label>
                        <textarea id="blk-data" rows="6">{"mensaje":"hola blockchain"}</textarea>
                        <div class="cols-3">
                            <div>
                                <label class="small muted">√çndice</label>
                                <input id="blk-index" type="number" value="1" />
                            </div>
                            <div>
                                <label class="small muted">Prev. Hash</label>
                                <input id="blk-prev"
                                    value="0000000000000000000000000000000000000000000000000000000000000000" />
                            </div>
                            <div>
                                <label class="small muted">Dificultad</label>
                                <input id="blk-diff" type="number" min="1" max="64" value="3" />
                            </div>
                        </div>
                        <div class="row">
                            <button id="btn-mine" class="good">Minar</button>
                            <button id="btn-stop" class="bad">Parar</button>
                        </div>
                    </div>
                    <div class="list">
                        <label class="small muted">Nonce</label>
                        <input id="blk-nonce" type="number" value="0" />
                        <label class="small muted">Timestamp</label>
                        <input id="blk-time" />
                        <label class="small muted">Hash</label>
                        <pre id="blk-hash" class="mono"></pre>
                        <div class="row kpi">
                            <span class="badge" id="mine-status">‚ùå No Minado</span>
                            <!-- Indicador de minado (visible solo mientras se mina) -->
                            <div id="mining-indicator" class="row small"
                                style="display:none;align-items:center;gap:8px">
                                <!-- Spinner SVG sin CSS externo -->
                                <svg width="18" height="18" viewBox="0 0 50 50" aria-hidden="true">
                                    <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="6"
                                        opacity="0.25" />
                                    <path fill="currentColor" d="M25 5a20 20 0 0 1 20 20h-6a14 14 0 0 0-14-14V5z">
                                        <animateTransform attributeName="transform" type="rotate" from="0 25 25"
                                            to="360 25 25" dur="0.9s" repeatCount="indefinite" />
                                    </path>
                                </svg>
                                <span>Minando‚Ä¶</span>
                            </div>

                        </div>
                    </div>
                </div>
            </section>

            <!-- 3) BLOCKCHAIN (con pares) -->
            <section id="sec-chain" class="card">
                <h2>3) Blockchain por pares</h2>
                <p>
                    Crea bloques en <strong>Par A</strong> y pulsa <em>A√±adir Par</em> para clonar el par anterior
                    (Par B, Par C, ‚Ä¶). Una vez copiado, cada par es completamente independiente.
                </p>
                <div class="row" style="align-items:center;gap:8px">
                    <button id="btn-pair-add" class="primary">A√±adir Par</button>

                    <!-- Controles de zoom -->
                    <div class="row" style="margin-left:auto;align-items:center;gap:6px">
                        <button id="btn-zoom-out" title="Desampliar"
                            style="width:36px;padding:6px 0;font-weight:700">‚àí</button>
                        <span class="pill" id="zoom-label">100%</span>
                        <button id="btn-zoom-in" title="Ampliar"
                            style="width:36px;padding:6px 0;font-weight:700">+</button>
                    </div>
                </div>

                <div class="hr"></div>
                <!-- Contenedor horizontal de pares -->
                <div id="pairs-container" class="list"
                    style="display:grid;grid-auto-flow:column;grid-auto-columns:640px;gap:16px;overflow-x:auto;overflow-y:hidden;padding-bottom:6px;">
                </div>

            </section>



            <!-- 4) RED DISTRIBUIDA -->
            <section id="sec-net" class="card">
                <h2>4) Blockchain distribuida (3 nodos)</h2>
                <p>Simula tres nodos. Cada uno puede minar su propio bloque. Luego <em>sincroniza</em> para resolver
                    conflictos eligiendo la <strong>cadena m√°s larga v√°lida</strong>.</p>
                <div class="row">
                    <button id="btn-net-new" class="primary">Reiniciar red</button>
                    <button id="btn-net-sync" class="good">Sincronizar red (consenso)</button>
                </div>
                <div class="hr"></div>
                <div class="cols-3" id="nodes"></div>
            </section>

            <!-- 5) COINBASE & TRANSACCIONES -->
            <section id="sec-coinbase" class="card">
                <h2>5) Coinbase & transacciones</h2>
                <p>En cada bloque minado se incluye una <em>coinbase</em> que paga una recompensa al minero. Env√≠a
                    transacciones y mina para confirmarlas.</p>
                <div class="row" style="gap:12px">
                    <label class="small muted">Nodo activo:</label>
                    <select id="tx-node"></select>
                    <label class="small muted">Recompensa por bloque:</label>
                    <input id="tx-reward" type="number" value="50" style="width:90px" />
                </div>
                <div class="cols-3">
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Crear transacci√≥n</strong>
                            <span class="badge small">Mempool</span>
                        </div>
                        <div class="list">
                            <label class="small muted">De (direcci√≥n)</label>
                            <input id="tx-from" placeholder="alice" />
                            <label class="small muted">A (direcci√≥n)</label>
                            <input id="tx-to" placeholder="bob" />
                            <label class="small muted">Cantidad</label>
                            <input id="tx-amount" type="number" value="10" />
                            <button id="btn-tx-add" class="primary">A√±adir a mempool</button>
                            <div class="hr"></div>
                            <div class="scroll">
                                <pre id="mempool-view" class="mono small"></pre>
                            </div>
                        </div>
                    </div>
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Miner√≠a con coinbase</strong>
                            <span class="badge small">‚õèÔ∏è</span>
                        </div>
                        <div class="list">
                            <label class="small muted">Minero (direcci√≥n que cobra coinbase)</label>
                            <input id="miner-addr" placeholder="miner1" value="miner1" />
                            <button id="btn-mine-mempool" class="good">Minar bloque con mempool</button>
                            <div id="mine-coinbase-status" class="small muted"></div>
                        </div>
                    </div>
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Balances (escaneando la cadena)</strong>
                            <span class="badge small">Œ£</span>
                        </div>
                        <div class="list">
                            <button id="btn-balances">Recalcular balances</button>
                            <div class="scroll">
                                <pre id="balances-view" class="mono small"></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </main>

    <script>
        // -------- Utilidades --------
        const enc = new TextEncoder();
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const hex = (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        async function sha256(str) {
            if (!window.isSecureContext) {
                // crypto.subtle requiere contexto seguro; avisamos pero intentamos igualmente
            }
            const data = enc.encode(str);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return hex(digest);
        }
        function nowISO() { return new Date().toISOString() }
        function el(id) { return document.getElementById(id) }

        // -------- Modelo de datos --------
        class Block {
            constructor({ index, timestamp, transactions, previousHash, nonce, difficulty }) {
                this.index = index;
                this.timestamp = timestamp || nowISO();
                this.transactions = transactions || []; // array de TX
                this.previousHash = previousHash || '0'.repeat(64);
                this.nonce = nonce || 0;
                this.difficulty = difficulty || 2;
                this.hash = '';
            }
            canonical() {
                // Cadena can√≥nica para hash (orden estable)
                return JSON.stringify({
                    index: this.index,
                    timestamp: this.timestamp,
                    transactions: this.transactions,
                    previousHash: this.previousHash,
                    nonce: this.nonce,
                    difficulty: this.difficulty
                });
            }
            async computeHash() {
                this.hash = await sha256(this.canonical());
                return this.hash;
            }
            async mine() {
                let target = '0'.repeat(this.difficulty);
                let attempts = 0;
                while (true) {
                    attempts++;
                    this.hash = await sha256(this.canonical());
                    if (this.hash.startsWith(target)) return { hash: this.hash, attempts };
                    this.nonce++;
                    // Deja respirar al event loop de vez en cuando
                    if (attempts % 300 === 0) await sleep(0);
                }
            }
        }

        class Blockchain {
            constructor({ difficulty = 3, reward = 50 } = {}) {
                this.chain = [];
                this.difficulty = difficulty;
                this.mempool = []; // TX pendientes
                this.reward = reward;
                this.createGenesis();
            }
            async createGenesis() {
                const g = new Block({ index: 0, timestamp: nowISO(), transactions: [{ coinbase: true, to: 'satoshi', amount: 0 }], previousHash: '0'.repeat(64), nonce: 0, difficulty: 1 });
                await g.computeHash();
                this.chain = [g];
            }
            get last() { return this.chain[this.chain.length - 1] }
            async addBlockFrom({ transactions, miner }) {
                // coinbase + mempool
                const txs = [{ coinbase: true, to: miner, amount: this.reward }, ...(transactions || this.mempool)];
                const b = new Block({ index: this.last.index + 1, timestamp: nowISO(), transactions: txs, previousHash: this.last.hash, nonce: 0, difficulty: this.difficulty });
                await b.mine();
                this.chain.push(b);
                // limpiar mempool s√≥lo de las tx incluidas (para demo, todas)
                this.mempool = [];
                return b;
            }
            async addExternalBlock(b) {
                // Validaci√≥n b√°sica de bloque externo
                const prev = this.last;
                if (b.previousHash !== prev.hash) return false;
                // Recalcular hash
                const temp = new Block(b);
                const h = await sha256(temp.canonical());
                if (h !== b.hash) return false;
                if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false;
                this.chain.push(b);
                return true;
            }
            async isValid() {
                for (let i = 1; i < this.chain.length; i++) {
                    const a = this.chain[i - 1], b = this.chain[i];
                    const temp = new Block(b);
                    const h = await sha256(temp.canonical());
                    if (b.previousHash !== a.hash) return false;
                    if (h !== b.hash) return false;
                    if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false;
                }
                return true;
            }
            balances() {
                const bal = {};
                for (const block of this.chain) {
                    for (const tx of block.transactions || []) {
                        if (tx.coinbase) {
                            bal[tx.to] = (bal[tx.to] || 0) + tx.amount;
                        } else {
                            if (tx.from) { bal[tx.from] = (bal[tx.from] || 0) - tx.amount; }
                            if (tx.to) { bal[tx.to] = (bal[tx.to] || 0) + tx.amount; }
                        }
                    }
                }
                return bal;
            }
            canSpend(addr, amount) {
                const bal = this.balances();
                return (bal[addr] || 0) >= amount;
            }
        }

        // -------- Estado global --------
        let chain = new Blockchain({ difficulty: 3, reward: 50 });

        // Red de 3 nodos
        const nodes = [new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 })];
        const minerAddrs = ['miner1', 'miner2', 'miner3'];

        // -------- UI: Hash --------
        function updateSecure() {
            el('secure-origin').textContent = 'Contexto: ' + (window.isSecureContext ? 'seguro (OK para crypto.subtle)' : 'no seguro (sirve la p√°gina via http://localhost)');
        }
        updateSecure();

        el('btn-hash').addEventListener('click', async () => {
            const text = el('hash-input').value || '';
            el('hash-output').textContent = 'calculando‚Ä¶';
            try {
                const h = await sha256(text);
                el('hash-output').textContent = h;
            } catch (e) {
                el('hash-output').textContent = 'Error: ' + e.message + '\nSugerencia: abre mediante http://localhost (no file://).';
            }
        });

        // -------- UI: Bloque --------
        function parseJSONsafe(s) { try { return JSON.parse(s) } catch { return null } }

        //// Re-evaluar "Minado / No Minado" usando el hash actual y la dificultad actual
        //function updateStatusFromCurrentHash() {
        //    const h = (el('blk-hash').textContent || '').trim();
        //    const mined = meetsDifficulty(h, getDifficulty());
        //    setVisual(mined);
        //}
        //
        //// La dificultad NO cambia el hash; solo el estado visual
        //el('blk-diff').addEventListener('input', updateStatusFromCurrentHash);


        // Normaliza dificultad (solo umbral de ceros; NO entra al hash)
        // Dificultad (umbral de ceros). No entra en el hash.
        // Fuerza rango [1, 64] y normaliza el input visible.
        function getDifficulty() {
            const raw = el('blk-diff').value;
            let v = parseInt(raw, 10);
            if (!Number.isFinite(v)) v = 1;
            v = Math.max(1, Math.min(64, v));
            if (String(v) !== String(raw)) el('blk-diff').value = v;
            return v;
        }

        // Canonicalizaci√≥n SOLO con los campos de contenido (sin dificultad)
        function uiCanonicalFromInputs() {
            return JSON.stringify({
                index: Number(el('blk-index').value || 1),
                timestamp: el('blk-time').value || nowISO(),
                // üëá usar exactamente lo escrito en el textarea, sin parsear
                data: el('blk-data').value ?? '',
                previousHash: el('blk-prev').value || '0'.repeat(64),
                nonce: Number(el('blk-nonce').value || 0)
            });
        }


        // Borra el bot√≥n "Calcular hash" si a√∫n est√° en el DOM
        (() => {
            const btn = document.getElementById('btn-blk-hash');
            if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
        })();

        // Visual: estado ‚ÄúMinado / No Minado‚Äù y color de toda la secci√≥n
        function setVisual(mined) {
            const s = el('mine-status');
            s.textContent = mined ? '‚úÖ Minado' : '‚ùå No Minado';
            s.style.background = mined ? 'var(--ok)' : 'var(--bad)';
            s.style.borderColor = mined ? 'var(--ok)' : 'var(--bad)';
            s.style.color = '#fff';
            // Colorear toda la secci√≥n
            const sec = el('sec-bloque');
            if (mined) {
                sec.style.borderColor = 'var(--ok)';
                sec.style.boxShadow = '0 10px 35px rgba(16,185,129,0.25)';
                sec.style.background = 'linear-gradient(180deg, #0f1f19, #0a1512)';
            } else {
                sec.style.borderColor = 'var(--bad)';
                sec.style.boxShadow = '0 10px 35px rgba(239,68,68,0.25)';
                sec.style.background = 'linear-gradient(180deg, #1f0f12, #150a0c)';
            }
        }

        function showMining(on) {
            const d = el('mining-indicator');
            if (!d) return;
            d.style.display = on ? 'flex' : 'none';
        }


        // Comprueba si el hash cumple la dificultad (capado a 64)
        function meetsDifficulty(hash, d) {
            const dd = Math.max(1, Math.min(64, Number(d) || 1));
            const need = '0'.repeat(dd);
            return !!hash && hash.startsWith(need);
        }

        // Recalcular hash autom√°ticamente al cambiar cualquier dato del bloque
        let hashCalcVersion = 0;
        async function recomputeHashAuto() {
            const myVersion = ++hashCalcVersion;
            // Construye la cadena can√≥nica SIN dificultad
            const payload = uiCanonicalFromInputs();
            el('blk-hash').textContent = 'calculando‚Ä¶';
            const newHash = await sha256(payload);
            // Evita condiciones de carrera: solo aplica el √∫ltimo c√°lculo
            if (myVersion !== hashCalcVersion) return;
            el('blk-hash').textContent = newHash;

            // Actualiza estado de minado seg√∫n dificultad actual
            const mined = meetsDifficulty(newHash, getDifficulty());
            setVisual(mined);
        }

        // Recalcula hash y estado SOLO al cambiar datos del bloque (NO dificultad)
        ['blk-data', 'blk-index', 'blk-prev', 'blk-nonce', 'blk-time'].forEach(id => {
            const n = el(id);
            if (!n) return;
            n.addEventListener('input', () => {
                recomputeHashAuto();   // recalcula hash y pinta estado
            });
        });



        // Timestamp inicial si est√° vac√≠o
        if (!el('blk-time').value) el('blk-time').value = nowISO();

        // Estado inicial coherente
        setVisual(false);
        recomputeHashAuto();

        // --- Minado ---
        let stopMining = false;
        el('btn-stop').addEventListener('click', () => {
            stopMining = true;
            showMining(false); // ocultar el indicador al parar
            // El estado visual se recalcular√° con recomputeHashAuto si cambias algo
        });

        el('btn-mine').addEventListener('click', async () => {
            stopMining = false;
            showMining(true);   // mostrar ‚ÄúMinando‚Ä¶‚Äù mientras trabaja

            const idx = Number(el('blk-index').value || 1);
            const ts = el('blk-time').value || nowISO();
            const prev = el('blk-prev').value || '0'.repeat(64);
            let nonce = Number(el('blk-nonce').value || 0);
            const d = getDifficulty();
            const target = '0'.repeat(d);

            // Importante: usar el texto crudo del textarea
            const dataRaw = el('blk-data').value ?? '';

            let attempts = 0;
            while (!stopMining) {
                const payload = JSON.stringify({
                    index: idx, timestamp: ts, data: dataRaw, previousHash: prev, nonce
                });
                const h = await sha256(payload);
                if (h.startsWith(target)) {
                    el('blk-nonce').value = nonce;
                    el('blk-hash').textContent = h;
                    setVisual(true);
                    showMining(false); // ocultar al terminar
                    return;
                }
                nonce++;
                attempts++;
                if (attempts % 500 === 0) await sleep(0);
            }

            // Si se detuvo, escondemos el indicador y refrescamos estado/hash actuales
            showMining(false);
            recomputeHashAuto();
        });




        // -------- UI: Blockchain por pares (clonaci√≥n e independencia) --------
        (() => {
            const ZERO64 = '0'.repeat(64);
            const pairsWrap = el('pairs-container');
            const btnAddPair = el('btn-pair-add');
            // --- Zoom +/‚àí de la vista de pares ---
            // Rango y paso de zoom (puedes ajustarlo)
            let zoom = 1;
            const ZMIN = 0.2, ZMAX = 1.5, ZSTEP = 0.1;

            function clamp(n, a, b) { return Math.min(b, Math.max(a, n)); }
            function applyZoom() {
                // Nota: 'zoom' no es est√°ndar pero funciona muy bien en Chrome/Edge/Safari.
                // Si necesitas compatibilidad total (Firefox), te preparo un fallback.
                pairsWrap.style.zoom = String(zoom);
                const label = el('zoom-label');
                if (label) label.textContent = Math.round(zoom * 100) + '%';
            }

            // Botones +/‚àí
            const btnZoomIn = el('btn-zoom-in');
            const btnZoomOut = el('btn-zoom-out');

            btnZoomIn?.addEventListener('click', () => {
                zoom = clamp(+(zoom + ZSTEP).toFixed(2), ZMIN, ZMAX);
                applyZoom();
            });
            btnZoomOut?.addEventListener('click', () => {
                zoom = clamp(+(zoom - ZSTEP).toFixed(2), ZMIN, ZMAX);
                applyZoom();
            });

            // Opcional: Ctrl + rueda (solo si te apetece)
            // pairsWrap.addEventListener('wheel', (e) => {
            //   if (!e.ctrlKey) return;
            //   e.preventDefault();
            //   zoom = clamp(+(zoom + (e.deltaY < 0 ? ZSTEP : -ZSTEP)).toFixed(2), ZMIN, ZMAX);
            //   applyZoom();
            // }, { passive: false });

            applyZoom(); // inicial


            // Utilidad: 0->A, 1->B, ‚Ä¶ 25->Z, 26->AA, etc.
            function letters(n) {
                n = Number(n) || 0;
                let s = ''; n++;
                while (n > 0) { const r = (n - 1) % 26; s = String.fromCharCode(65 + r) + s; n = Math.floor((n - 1) / 26); }
                return s;
            }

            // --------- Componente tarjeta de bloque (reutilizable por par) ---------
            function makeBlockCard({ index, prevHash, defaultDifficulty, initialTimestamp, snapshot } = {}) {
                const wrap = document.createElement('div');
                wrap.className = 'node';
                wrap.style.padding = '12px';
                wrap.innerHTML = `
      <div class="cols-2">
        <div class="list">
          <label>Datos (JSON libre)</label>
          <textarea class="data" rows="6">{\"mensaje\":\"hola blockchain\"}</textarea>
          <div class="cols-3">
            <div>
              <label class="small muted">√çndice</label>
              <input class="index" type="number" />
            </div>
            <div>
              <label class="small muted">Prev. Hash</label>
              <input class="prev" />
            </div>
            <div>
              <label class="small muted">Dificultad</label>
              <input class="diff" type="number" min="1" max="64" />
            </div>
          </div>
          <div class="row">
            <button class="mine good">Minar</button>
            <button class="stop bad">Parar</button>
          </div>
        </div>
        <div class="list">
          <label class="small muted">Nonce</label>
          <input class="nonce" type="number" value="0" />
          <label class="small muted">Timestamp</label>
          <input class="time" />
          <label class="small muted">Hash</label>
          <pre class="hash mono"></pre>
          <div class="row kpi">
            <span class="badge status">‚ùå No Minado</span>
            <div class="row small indicator" style="display:none;align-items:center;gap:8px">
              <svg width="18" height="18" viewBox="0 0 50 50" aria-hidden="true">
                <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="6" opacity="0.25" />
                <path fill="currentColor" d="M25 5a20 20 0 0 1 20 20h-6a14 14 0 0 0-14-14V5z">
                  <animateTransform attributeName="transform" type="rotate" from="0 25 25"
                    to="360 25 25" dur="0.9s" repeatCount="indefinite" />
                </path>
              </svg>
              <span>Minando‚Ä¶</span>
            </div>
          </div>
        </div>
      </div>
    `;

                // Refs
                const refs = {
                    data: wrap.querySelector('.data'),
                    index: wrap.querySelector('.index'),
                    prev: wrap.querySelector('.prev'),
                    diff: wrap.querySelector('.diff'),
                    mine: wrap.querySelector('.mine'),
                    stop: wrap.querySelector('.stop'),
                    nonce: wrap.querySelector('.nonce'),
                    time: wrap.querySelector('.time'),
                    hash: wrap.querySelector('.hash'),
                    indicator: wrap.querySelector('.indicator'),
                    status: wrap.querySelector('.status'),
                };

                // Visual del estado de minado
                function setCardVisual(mined) {
                    refs.status.textContent = mined ? '‚úÖ Minado' : '‚ùå No Minado';
                    refs.status.style.background = mined ? 'var(--ok)' : 'var(--bad)';
                    refs.status.style.borderColor = mined ? 'var(--ok)' : 'var(--bad)';
                    refs.status.style.color = '#fff';
                    if (mined) {
                        wrap.style.borderColor = 'var(--ok)';
                        wrap.style.boxShadow = '0 10px 35px rgba(16,185,129,0.25)';
                        wrap.style.background = 'linear-gradient(180deg, #0f1f19, #0a1512)';
                    } else {
                        wrap.style.borderColor = 'var(--bad)';
                        wrap.style.boxShadow = '0 10px 35px rgba(239,68,68,0.25)';
                        wrap.style.background = 'linear-gradient(180deg, #1f0f12, #150a0c)';
                    }
                }

                // Init campos (o desde snapshot)
                if (snapshot) {
                    refs.index.value = Number(snapshot.index);
                    refs.prev.value = snapshot.prev || ZERO64;
                    refs.diff.value = Number(snapshot.diff ?? 3);
                    refs.nonce.value = Number(snapshot.nonce ?? 0);
                    refs.time.value = snapshot.time || nowISO();
                    refs.data.value = snapshot.data ?? '';
                } else {
                    refs.index.value = Number(index ?? 1);
                    refs.prev.value = prevHash || ZERO64;
                    refs.diff.value = Number(defaultDifficulty ?? 3);
                    refs.nonce.value = 0;
                    refs.time.value = initialTimestamp || nowISO();
                }

                // index/prev no editables (se calculan por posici√≥n)
                refs.index.readOnly = true;
                refs.prev.readOnly = true;

                // Helpers
                let localVersion = 0;
                let stopMining = false;
                let notify = async () => { }; // lo conectaremos desde fuera (para cascada en el par)

                function localGetDifficulty() {
                    let v = parseInt(refs.diff.value, 10);
                    if (!Number.isFinite(v)) v = 1;
                    v = Math.max(1, Math.min(64, v));
                    if (String(v) !== String(refs.diff.value)) refs.diff.value = v;
                    return v;
                }

                function localPayload() {
                    return JSON.stringify({
                        index: Number(refs.index.value || 1),
                        timestamp: refs.time.value || nowISO(),
                        data: refs.data.value ?? '',
                        previousHash: refs.prev.value || ZERO64,
                        nonce: Number(refs.nonce.value || 0),
                    });
                }

                async function recompute() {
                    const myVer = ++localVersion;
                    refs.hash.textContent = 'calculando‚Ä¶';
                    const h = await sha256(localPayload());
                    if (myVer !== localVersion) return h;
                    refs.hash.textContent = h;
                    const mined = meetsDifficulty(h, localGetDifficulty());
                    setCardVisual(mined);
                    return h;
                }

                function showMining(show) { refs.indicator.style.display = show ? 'flex' : 'none'; }

                // Eventos: cualquier cambio -> recomputa y notifica cascada
                [refs.data, refs.index, refs.prev, refs.nonce, refs.time].forEach(n => {
                    n.addEventListener('input', async () => { await recompute(); await notify(); });
                });
                // La dificultad no cambia el hash, pero s√≠ el estado ‚ÄúMinado/No Minado‚Äù
                refs.diff.addEventListener('input', async () => { await recompute(); await notify(); });

                refs.stop.addEventListener('click', () => { stopMining = true; showMining(false); });

                refs.mine.addEventListener('click', async () => {
                    stopMining = false; showMining(true);
                    const idx = Number(refs.index.value || 1);
                    const ts = refs.time.value || nowISO();
                    const prev = refs.prev.value || ZERO64;
                    let nonce = Number(refs.nonce.value || 0);
                    const d = localGetDifficulty();
                    const target = '0'.repeat(d);
                    const dataRaw = refs.data.value ?? '';

                    let attempts = 0;
                    while (!stopMining) {
                        const payload = JSON.stringify({ index: idx, timestamp: ts, data: dataRaw, previousHash: prev, nonce });
                        const h = await sha256(payload);
                        if (h.startsWith(target)) {
                            refs.nonce.value = nonce;
                            refs.hash.textContent = h;
                            setCardVisual(true);
                            showMining(false);
                            await notify(); // propaga
                            return;
                        }
                        nonce++; attempts++; if (attempts % 500 === 0) await sleep(0);
                    }
                    showMining(false);
                    await recompute();
                    await notify();
                });

                // Estado inicial
                setCardVisual(false);
                // Si venimos de snapshot quiz√° ya estaba minado: recalculamos para pintar consistente
                recompute();

                return {
                    wrap,
                    refs,
                    recompute,
                    get hash() { return (refs.hash.textContent || '').trim(); },
                    setNotify(fn) { notify = fn; }
                };
            }
            // ----------------------------------------------------------------------

            // Estructura de pares
            const pairs = []; // { name, col, refs, cards, cascadeFrom }

            function makePair(fromPair = null) {
                const idx = pairs.length;
                const name = 'Par ' + letters(idx);

                const col = document.createElement('div');
                col.className = 'node';
                col.style.padding = '12px';
                col.style.minWidth = '640px'; // mismo valor que en grid-auto-columns
                col.innerHTML = `
      <div class="row" style="justify-content:space-between;align-items:center">
        <strong>${name}</strong>
        <button class="primary add-block">A√±adir bloque</button>
      </div>
      <div class="hr"></div>
      <div class="list blocks"></div>
    `;

                const refs = {
                    addBlock: col.querySelector('.add-block'),
                    blocks: col.querySelector('.blocks'),
                };

                const cards = [];

                async function cascadeFrom(startIdx) {
                    for (let i = startIdx; i < cards.length; i++) {
                        const prevH = cards[i - 1].hash || ZERO64;
                        cards[i].refs.prev.value = prevH;
                        await cards[i].recompute();
                    }
                }

                function connectNotifies() {
                    cards.forEach(c => c.setNotify(async () => {
                        const pos = cards.indexOf(c);
                        await cascadeFrom(pos + 1);
                    }));
                }

                // A√±adir bloque manual en este par
                refs.addBlock.addEventListener('click', async () => {
                    let prevHash = ZERO64;
                    if (cards.length > 0) {
                        await cards[cards.length - 1].recompute();
                        prevHash = cards[cards.length - 1].hash || ZERO64;
                    }
                    const creationTs = nowISO();
                    const defaultDiff = Number(el('blk-diff')?.value || 3); // reusa el selector de dificultad del bloque de la secci√≥n 2
                    const card = makeBlockCard({
                        index: cards.length + 1,
                        prevHash,
                        defaultDifficulty: defaultDiff,
                        initialTimestamp: creationTs
                    });
                    refs.blocks.appendChild(card.wrap);
                    cards.push(card);
                    connectNotifies();
                });

                // Si hay par de origen: clonar todos sus bloques
                if (fromPair && Array.isArray(fromPair.cards)) {
                    (async () => {
                        for (const src of fromPair.cards) {
                            const snap = {
                                index: Number(src.refs.index.value),
                                data: src.refs.data.value,
                                prev: src.refs.prev.value,
                                diff: Number(src.refs.diff.value),
                                nonce: Number(src.refs.nonce.value),
                                time: src.refs.time.value,
                            };
                            const card = makeBlockCard({ snapshot: snap });
                            refs.blocks.appendChild(card.wrap);
                            cards.push(card);
                            await card.recompute(); // pinta hash/estado coherente
                        }
                        connectNotifies();
                    })();
                }

                const pair = { name, col, refs, cards, cascadeFrom };
                pairs.push(pair);
                pairsWrap.appendChild(col);
                return pair;
            }

            // Bot√≥n global: clona el √∫ltimo par (si no hay, crea Par A vac√≠o)
            btnAddPair.addEventListener('click', () => {
                const last = pairs[pairs.length - 1] || null;
                makePair(last || null);
            });

            // Inicio: crea Par A vac√≠o
            makePair(null);
        })();




        // -------- UI: Red distribuida --------
        function nodeCard(i) {
            const n = nodes[i];
            const top = n.last.hash.slice(0, 12) + '‚Ä¶';
            const div = document.createElement('div');
            div.className = 'node';
            div.innerHTML = `
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Nodo ${i + 1}</strong>
          <span class="badge">altura ${n.chain.length - 1}</span>
        </div>
        <div class="small muted">head: ${top}</div>
        <div class="hr"></div>
        <div class="list small">
          <label class="small muted">Minero de nodo</label>
          <input data-miner="${i}" value="${minerAddrs[i]}" />
          <button data-mine="${i}" class="good">Minar 1 bloque</button>
          <button data-show="${i}">Ver cadena</button>
          <div class="scroll"><pre class="mono small" id="node-view-${i}"></pre></div>
        </div>`;
            return div;
        }

        function renderNodes() {
            const wrap = el('nodes');
            wrap.innerHTML = '';
            nodes.forEach((_, i) => wrap.appendChild(nodeCard(i)));
            wrap.querySelectorAll('button[data-mine]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const i = Number(e.target.getAttribute('data-mine'));
                    const miner = wrap.querySelector(`input[data-miner="${i}"]`).value || minerAddrs[i];
                    nodes[i].reward = Number(el('tx-reward').value) || 50;
                    await nodes[i].addBlockFrom({ transactions: [], miner });
                    renderNodes();
                });
            });
            wrap.querySelectorAll('button[data-show]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const i = Number(e.target.getAttribute('data-show'));
                    const pre = el(`node-view-${i}`);
                    pre.textContent = JSON.stringify(nodes[i].chain.map(b => ({ i: b.index, hash: b.hash.slice(0, 16) + '‚Ä¶', prev: b.previousHash.slice(0, 10) + '‚Ä¶' })), null, 2);
                });
            });
            wrap.querySelectorAll('input[data-miner]').forEach(inp => {
                inp.addEventListener('change', (e) => {
                    const i = Number(e.target.getAttribute('data-miner'));
                    minerAddrs[i] = e.target.value;
                })
            })
        }
        renderNodes();

        el('btn-net-new').addEventListener('click', async () => {
            for (let i = 0; i < nodes.length; i++) { nodes[i] = new Blockchain({ difficulty: 3, reward: Number(el('tx-reward').value) || 50 }); await nodes[i].createGenesis(); }
            renderNodes();
        });

        el('btn-net-sync').addEventListener('click', async () => {
            // Consenso muy simple: elige la cadena v√°lida m√°s larga. Si hay empate, la primera.
            let best = nodes[0];
            for (const n of nodes) { if (n.chain.length > best.chain.length) best = n; }
            // Replicar
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i] !== best) { nodes[i].chain = JSON.parse(JSON.stringify(best.chain)); }
            }
            renderNodes();
        });

        // -------- UI: Coinbase & TX --------
        function refreshNodeSelect() {
            const sel = el('tx-node');
            sel.innerHTML = '';
            ['Nodo 1', 'Nodo 2', 'Nodo 3'].forEach((lab, i) => {
                const o = document.createElement('option'); o.value = String(i); o.textContent = lab; sel.appendChild(o);
            });
        }
        refreshNodeSelect();

        function renderMempool() {
            const n = nodes[Number(el('tx-node').value || 0)];
            el('mempool-view').textContent = JSON.stringify(n.mempool, null, 2);
        }

        function renderBalances() {
            const n = nodes[Number(el('tx-node').value || 0)];
            const bal = n.balances();
            const rows = Object.keys(bal).sort().map(k => `${k}: ${bal[k]}`);
            el('balances-view').textContent = rows.join('\n') || '(sin movimientos a√∫n)';
        }

        el('tx-node').addEventListener('change', () => { renderMempool(); renderBalances(); });

        el('btn-tx-add').addEventListener('click', () => {
            const n = nodes[Number(el('tx-node').value || 0)];
            const from = el('tx-from').value.trim();
            const to = el('tx-to').value.trim();
            const amount = Number(el('tx-amount').value || 0);
            if (!to || amount <= 0) { alert('Completa destinatario y cantidad>0'); return; }
            if (from && !n.canSpend(from, amount)) {
                alert('Saldo insuficiente en ' + from + ' (recuerda minar coinbase primero)');
                return;
            }
            n.mempool.push({ from, to, amount });
            renderMempool();
        });

        el('btn-mine-mempool').addEventListener('click', async () => {
            const idx = Number(el('tx-node').value || 0);
            const n = nodes[idx];
            n.reward = Number(el('tx-reward').value) || 50;
            const miner = el('miner-addr').value.trim() || 'miner' + (idx + 1);
            el('mine-coinbase-status').textContent = 'Minando‚Ä¶';
            const b = await n.addBlockFrom({ transactions: n.mempool, miner });
            el('mine-coinbase-status').textContent = 'Bloque #' + b.index + ' minado. Hash ' + b.hash.slice(0, 12) + '‚Ä¶';
            renderMempool();
            renderBalances();
            renderNodes();
        });

        el('btn-balances').addEventListener('click', () => { renderBalances(); });

        // Inicial
        renderMempool();
        renderBalances();
    </script>
</body>

</html>