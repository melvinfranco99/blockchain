<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mini Blockchain Playground</title>
    <style>
        :root {
            --bg: #0f172a;
            /* slate-900 */
            --panel: #111827;
            /* gray-900 */
            --muted: #9ca3af;
            /* gray-400 */
            --text: #f3f4f6;
            /* gray-100 */
            --accent: #22d3ee;
            /* cyan-400 */
            --ok: #10b981;
            /* emerald-500 */
            --warn: #f59e0b;
            /* amber-500 */
            --bad: #ef4444;
            /* red-500 */
            --card: #0b1220;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, #0b1220, #0f172a 20%, #0b1220 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu;
        }

        header {
            position: sticky;
            top: 0;
            background: rgba(11, 18, 32, .6);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid #1f2937;
            z-index: 5
        }

        header .wrap {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 12px 16px
        }

        h1 {
            font-size: 20px;
            margin: 0;
            letter-spacing: .3px
        }

        .tag {
            font-size: 12px;
            color: var(--muted)
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            gap: 16px
        }

        section {
            grid-column: span 12;
            background: linear-gradient(180deg, #0d1526, #0a0f1c);
            border: 1px solid #1f2937;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, .35);
        }

        .card {
            padding: 18px 16px
        }

        section h2 {
            margin: 0 0 8px 0;
            font-size: 18px
        }

        section p {
            color: var(--muted);
            margin: 4px 0 10px 0
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        input,
        select,
        textarea,
        button {
            border-radius: 12px;
            border: 1px solid #334155;
            background: #0f172a;
            color: var(--text);
            padding: 10px 12px;
            font-size: 14px
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: 2px solid #334155
        }

        button {
            cursor: pointer;
            background: #0f172a
        }

        button.primary {
            background: linear-gradient(180deg, #0ea5e9, #06b6d4);
            border: none;
            color: #002b36;
            font-weight: 700
        }

        button.good {
            background: linear-gradient(180deg, #34d399, #10b981);
            border: none;
            color: #052e1a;
            font-weight: 700
        }

        button.warn {
            background: linear-gradient(180deg, #fbbf24, #f59e0b);
            border: none;
            color: #3b2000;
            font-weight: 700
        }

        button.bad {
            background: linear-gradient(180deg, #f87171, #ef4444);
            border: none;
            color: #3a0b0b;
            font-weight: 700
        }

        code,
        pre {
            background: #0b1324;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 10px 12px
        }

        pre {
            white-space: pre-wrap;
            word-break: break-word
        }

        .kpi {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .pill {
            border: 1px solid #273449;
            background: #0b1220;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted)
        }

        .list {
            display: grid;
            gap: 10px
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
        }

        details {
            background: #0b1324;
            border: 1px solid #223046;
            border-radius: 10px;
            padding: 10px 12px
        }

        summary {
            cursor: pointer
        }

        .cols-2 {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px
        }

        .cols-3 {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 12px
        }

        .muted {
            color: var(--muted)
        }

        .hr {
            height: 1px;
            background: #1f2937;
            margin: 12px 0
        }

        .small {
            font-size: 12px
        }

        .node {
            border: 1px solid #223046;
            border-radius: 12px;
            padding: 10px;
            background: #0c1528
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid #2b3d5c;
            background: #0e1830;
            font-size: 11px;
            color: #cbd5e1
        }

        .scroll {
            max-height: 220px;
            overflow: auto
        }
    </style>
</head>

<body>
    <header>
        <div class="wrap">
            <h1>üß± Mini Blockchain Playground</h1>
            <span class="tag">Secciones: Hash ‚Ä¢ Bloque ‚Ä¢ Blockchain ‚Ä¢ Distribuida ‚Ä¢ Coinbase</span>
        </div>
    </header>
    <main>
        <div class="grid">

            <!-- 1) HASH -->
            <section id="sec-hash" class="card">
                <h2>1) Hash</h2>
                <p>Escribe cualquier texto y calcula su <strong>SHA‚Äë256</strong>. Un cambio m√≠nimo cambia por completo
                    el hash.</p>
                <div class="row" style="gap:12px">
                    <input id="hash-input" placeholder="Texto a hashear" style="flex:1" />
                    <button id="btn-hash" class="primary">Calcular SHA‚Äë256</button>
                </div>
                <div class="hr"></div>
                <div class="list">
                    <div class="row kpi">
                        <span class="pill">Algoritmo: SHA‚Äë256</span>
                        <span class="pill" id="secure-origin">Contexto: comprobando‚Ä¶</span>
                    </div>
                    <label class="small muted">Hash (hex):</label>
                    <pre id="hash-output" class="mono"></pre>
                </div>
            </section>

            <!-- 2) BLOQUE (POW) -->
            <section id="sec-bloque" class="card">
                <h2>2) Bloque</h2>
                <p>Juega con un bloque y haz <em>miner√≠a</em> (Proof‚Äëof‚ÄëWork): busca un <code>nonce</code> tal que el
                    hash empiece con <code>0</code> repetido <em>difficulty</em> veces.</p>
                <div class="cols-2">
                    <div class="list">
                        <label>Datos (JSON libre)</label>
                        <textarea id="blk-data" rows="6">{"mensaje":"hola blockchain"}</textarea>
                        <div class="cols-3">
                            <div>
                                <label class="small muted">√çndice</label>
                                <input id="blk-index" type="number" value="1" />
                            </div>
                            <div>
                                <label class="small muted">Prev. Hash</label>
                                <input id="blk-prev"
                                    value="0000000000000000000000000000000000000000000000000000000000000000" />
                            </div>
                            <div>
                                <label class="small muted">Dificultad</label>
                                <input id="blk-diff" type="number" min="1" max="64" value="3" />
                            </div>
                        </div>
                        <div class="row">
                            <button id="btn-mine" class="good">Minar</button>
                            <button id="btn-stop" class="bad">Parar</button>
                        </div>
                    </div>
                    <div class="list">
                        <label class="small muted">Nonce</label>
                        <input id="blk-nonce" type="number" value="0" />
                        <label class="small muted">Timestamp</label>
                        <input id="blk-time" />
                        <label class="small muted">Hash</label>
                        <pre id="blk-hash" class="mono"></pre>
                        <div class="row kpi">
                            <span class="badge" id="mine-status">‚ùå No Minado</span>
                            <!-- Indicador de minado (visible solo mientras se mina) -->
                            <div id="mining-indicator" class="row small"
                                style="display:none;align-items:center;gap:8px">
                                <!-- Spinner SVG sin CSS externo -->
                                <svg width="18" height="18" viewBox="0 0 50 50" aria-hidden="true">
                                    <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="6"
                                        opacity="0.25" />
                                    <path fill="currentColor" d="M25 5a20 20 0 0 1 20 20h-6a14 14 0 0 0-14-14V5z">
                                        <animateTransform attributeName="transform" type="rotate" from="0 25 25"
                                            to="360 25 25" dur="0.9s" repeatCount="indefinite" />
                                    </path>
                                </svg>
                                <span>Minando‚Ä¶</span>
                            </div>

                        </div>
                    </div>
                </div>
            </section>

            <!-- 3) BLOCKCHAIN -->
            <section id="sec-chain" class="card">
                <h2>3) Blockchain</h2>
                <p>Crea una cadena, a√±ade bloques minados y verifica su integridad. Puedes <em>trucar</em> un bloque
                    para ver c√≥mo se invalida la cadena.</p>
                <div class="row">
                    <button id="btn-chain-new" class="primary">Nueva cadena</button>
                    <button id="btn-chain-add" class="good">A√±adir bloque (desde secci√≥n Bloque)</button>
                    <button id="btn-chain-validate">Validar cadena</button>
                    <button id="btn-chain-tamper" class="warn">Trucar bloque #1</button>
                    <span class="badge" id="chain-status">Estado: ‚Äî</span>
                </div>
                <div class="hr"></div>
                <div id="chain-view" class="list"></div>
            </section>

            <!-- 4) RED DISTRIBUIDA -->
            <section id="sec-net" class="card">
                <h2>4) Blockchain distribuida (3 nodos)</h2>
                <p>Simula tres nodos. Cada uno puede minar su propio bloque. Luego <em>sincroniza</em> para resolver
                    conflictos eligiendo la <strong>cadena m√°s larga v√°lida</strong>.</p>
                <div class="row">
                    <button id="btn-net-new" class="primary">Reiniciar red</button>
                    <button id="btn-net-sync" class="good">Sincronizar red (consenso)</button>
                </div>
                <div class="hr"></div>
                <div class="cols-3" id="nodes"></div>
            </section>

            <!-- 5) COINBASE & TRANSACCIONES -->
            <section id="sec-coinbase" class="card">
                <h2>5) Coinbase & transacciones</h2>
                <p>En cada bloque minado se incluye una <em>coinbase</em> que paga una recompensa al minero. Env√≠a
                    transacciones y mina para confirmarlas.</p>
                <div class="row" style="gap:12px">
                    <label class="small muted">Nodo activo:</label>
                    <select id="tx-node"></select>
                    <label class="small muted">Recompensa por bloque:</label>
                    <input id="tx-reward" type="number" value="50" style="width:90px" />
                </div>
                <div class="cols-3">
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Crear transacci√≥n</strong>
                            <span class="badge small">Mempool</span>
                        </div>
                        <div class="list">
                            <label class="small muted">De (direcci√≥n)</label>
                            <input id="tx-from" placeholder="alice" />
                            <label class="small muted">A (direcci√≥n)</label>
                            <input id="tx-to" placeholder="bob" />
                            <label class="small muted">Cantidad</label>
                            <input id="tx-amount" type="number" value="10" />
                            <button id="btn-tx-add" class="primary">A√±adir a mempool</button>
                            <div class="hr"></div>
                            <div class="scroll">
                                <pre id="mempool-view" class="mono small"></pre>
                            </div>
                        </div>
                    </div>
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Miner√≠a con coinbase</strong>
                            <span class="badge small">‚õèÔ∏è</span>
                        </div>
                        <div class="list">
                            <label class="small muted">Minero (direcci√≥n que cobra coinbase)</label>
                            <input id="miner-addr" placeholder="miner1" value="miner1" />
                            <button id="btn-mine-mempool" class="good">Minar bloque con mempool</button>
                            <div id="mine-coinbase-status" class="small muted"></div>
                        </div>
                    </div>
                    <div class="node">
                        <div class="row" style="justify-content:space-between;align-items:center">
                            <strong>Balances (escaneando la cadena)</strong>
                            <span class="badge small">Œ£</span>
                        </div>
                        <div class="list">
                            <button id="btn-balances">Recalcular balances</button>
                            <div class="scroll">
                                <pre id="balances-view" class="mono small"></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </main>

    <script>
        // -------- Utilidades --------
        const enc = new TextEncoder();
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const hex = (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        async function sha256(str) {
            if (!window.isSecureContext) {
                // crypto.subtle requiere contexto seguro; avisamos pero intentamos igualmente
            }
            const data = enc.encode(str);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return hex(digest);
        }
        function nowISO() { return new Date().toISOString() }
        function el(id) { return document.getElementById(id) }

        // -------- Modelo de datos --------
        class Block {
            constructor({ index, timestamp, transactions, previousHash, nonce, difficulty }) {
                this.index = index;
                this.timestamp = timestamp || nowISO();
                this.transactions = transactions || []; // array de TX
                this.previousHash = previousHash || '0'.repeat(64);
                this.nonce = nonce || 0;
                this.difficulty = difficulty || 2;
                this.hash = '';
            }
            canonical() {
                // Cadena can√≥nica para hash (orden estable)
                return JSON.stringify({
                    index: this.index,
                    timestamp: this.timestamp,
                    transactions: this.transactions,
                    previousHash: this.previousHash,
                    nonce: this.nonce,
                    difficulty: this.difficulty
                });
            }
            async computeHash() {
                this.hash = await sha256(this.canonical());
                return this.hash;
            }
            async mine() {
                let target = '0'.repeat(this.difficulty);
                let attempts = 0;
                while (true) {
                    attempts++;
                    this.hash = await sha256(this.canonical());
                    if (this.hash.startsWith(target)) return { hash: this.hash, attempts };
                    this.nonce++;
                    // Deja respirar al event loop de vez en cuando
                    if (attempts % 300 === 0) await sleep(0);
                }
            }
        }

        class Blockchain {
            constructor({ difficulty = 3, reward = 50 } = {}) {
                this.chain = [];
                this.difficulty = difficulty;
                this.mempool = []; // TX pendientes
                this.reward = reward;
                this.createGenesis();
            }
            async createGenesis() {
                const g = new Block({ index: 0, timestamp: nowISO(), transactions: [{ coinbase: true, to: 'satoshi', amount: 0 }], previousHash: '0'.repeat(64), nonce: 0, difficulty: 1 });
                await g.computeHash();
                this.chain = [g];
            }
            get last() { return this.chain[this.chain.length - 1] }
            async addBlockFrom({ transactions, miner }) {
                // coinbase + mempool
                const txs = [{ coinbase: true, to: miner, amount: this.reward }, ...(transactions || this.mempool)];
                const b = new Block({ index: this.last.index + 1, timestamp: nowISO(), transactions: txs, previousHash: this.last.hash, nonce: 0, difficulty: this.difficulty });
                await b.mine();
                this.chain.push(b);
                // limpiar mempool s√≥lo de las tx incluidas (para demo, todas)
                this.mempool = [];
                return b;
            }
            async addExternalBlock(b) {
                // Validaci√≥n b√°sica de bloque externo
                const prev = this.last;
                if (b.previousHash !== prev.hash) return false;
                // Recalcular hash
                const temp = new Block(b);
                const h = await sha256(temp.canonical());
                if (h !== b.hash) return false;
                if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false;
                this.chain.push(b);
                return true;
            }
            async isValid() {
                for (let i = 1; i < this.chain.length; i++) {
                    const a = this.chain[i - 1], b = this.chain[i];
                    const temp = new Block(b);
                    const h = await sha256(temp.canonical());
                    if (b.previousHash !== a.hash) return false;
                    if (h !== b.hash) return false;
                    if (!b.hash.startsWith('0'.repeat(b.difficulty))) return false;
                }
                return true;
            }
            balances() {
                const bal = {};
                for (const block of this.chain) {
                    for (const tx of block.transactions || []) {
                        if (tx.coinbase) {
                            bal[tx.to] = (bal[tx.to] || 0) + tx.amount;
                        } else {
                            if (tx.from) { bal[tx.from] = (bal[tx.from] || 0) - tx.amount; }
                            if (tx.to) { bal[tx.to] = (bal[tx.to] || 0) + tx.amount; }
                        }
                    }
                }
                return bal;
            }
            canSpend(addr, amount) {
                const bal = this.balances();
                return (bal[addr] || 0) >= amount;
            }
        }

        // -------- Estado global --------
        let chain = new Blockchain({ difficulty: 3, reward: 50 });

        // Red de 3 nodos
        const nodes = [new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 }), new Blockchain({ difficulty: 3, reward: 50 })];
        const minerAddrs = ['miner1', 'miner2', 'miner3'];

        // -------- UI: Hash --------
        function updateSecure() {
            el('secure-origin').textContent = 'Contexto: ' + (window.isSecureContext ? 'seguro (OK para crypto.subtle)' : 'no seguro (sirve la p√°gina via http://localhost)');
        }
        updateSecure();

        el('btn-hash').addEventListener('click', async () => {
            const text = el('hash-input').value || '';
            el('hash-output').textContent = 'calculando‚Ä¶';
            try {
                const h = await sha256(text);
                el('hash-output').textContent = h;
            } catch (e) {
                el('hash-output').textContent = 'Error: ' + e.message + '\nSugerencia: abre mediante http://localhost (no file://).';
            }
        });

        // -------- UI: Bloque --------
        function parseJSONsafe(s) { try { return JSON.parse(s) } catch { return null } }

        //// Re-evaluar "Minado / No Minado" usando el hash actual y la dificultad actual
        //function updateStatusFromCurrentHash() {
        //    const h = (el('blk-hash').textContent || '').trim();
        //    const mined = meetsDifficulty(h, getDifficulty());
        //    setVisual(mined);
        //}
        //
        //// La dificultad NO cambia el hash; solo el estado visual
        //el('blk-diff').addEventListener('input', updateStatusFromCurrentHash);


        // Normaliza dificultad (solo umbral de ceros; NO entra al hash)
        // Dificultad (umbral de ceros). No entra en el hash.
        // Fuerza rango [1, 64] y normaliza el input visible.
        function getDifficulty() {
            const raw = el('blk-diff').value;
            let v = parseInt(raw, 10);
            if (!Number.isFinite(v)) v = 1;
            v = Math.max(1, Math.min(64, v));
            if (String(v) !== String(raw)) el('blk-diff').value = v;
            return v;
        }

        // Canonicalizaci√≥n SOLO con los campos de contenido (sin dificultad)
        function uiCanonicalFromInputs() {
            return JSON.stringify({
                index: Number(el('blk-index').value || 1),
                timestamp: el('blk-time').value || nowISO(),
                // üëá usar exactamente lo escrito en el textarea, sin parsear
                data: el('blk-data').value ?? '',
                previousHash: el('blk-prev').value || '0'.repeat(64),
                nonce: Number(el('blk-nonce').value || 0)
            });
        }


        // Borra el bot√≥n "Calcular hash" si a√∫n est√° en el DOM
        (() => {
            const btn = document.getElementById('btn-blk-hash');
            if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
        })();

        // Visual: estado ‚ÄúMinado / No Minado‚Äù y color de toda la secci√≥n
        function setVisual(mined) {
            const s = el('mine-status');
            s.textContent = mined ? '‚úÖ Minado' : '‚ùå No Minado';
            s.style.background = mined ? 'var(--ok)' : 'var(--bad)';
            s.style.borderColor = mined ? 'var(--ok)' : 'var(--bad)';
            s.style.color = '#fff';
            // Colorear toda la secci√≥n
            const sec = el('sec-bloque');
            if (mined) {
                sec.style.borderColor = 'var(--ok)';
                sec.style.boxShadow = '0 10px 35px rgba(16,185,129,0.25)';
                sec.style.background = 'linear-gradient(180deg, #0f1f19, #0a1512)';
            } else {
                sec.style.borderColor = 'var(--bad)';
                sec.style.boxShadow = '0 10px 35px rgba(239,68,68,0.25)';
                sec.style.background = 'linear-gradient(180deg, #1f0f12, #150a0c)';
            }
        }

        function showMining(on) {
            const d = el('mining-indicator');
            if (!d) return;
            d.style.display = on ? 'flex' : 'none';
        }


        // Comprueba si el hash cumple la dificultad (capado a 64)
        function meetsDifficulty(hash, d) {
            const dd = Math.max(1, Math.min(64, Number(d) || 1));
            const need = '0'.repeat(dd);
            return !!hash && hash.startsWith(need);
        }

        // Recalcular hash autom√°ticamente al cambiar cualquier dato del bloque
        let hashCalcVersion = 0;
        async function recomputeHashAuto() {
            const myVersion = ++hashCalcVersion;
            // Construye la cadena can√≥nica SIN dificultad
            const payload = uiCanonicalFromInputs();
            el('blk-hash').textContent = 'calculando‚Ä¶';
            const newHash = await sha256(payload);
            // Evita condiciones de carrera: solo aplica el √∫ltimo c√°lculo
            if (myVersion !== hashCalcVersion) return;
            el('blk-hash').textContent = newHash;

            // Actualiza estado de minado seg√∫n dificultad actual
            const mined = meetsDifficulty(newHash, getDifficulty());
            setVisual(mined);
        }

        // Recalcula hash y estado SOLO al cambiar datos del bloque (NO dificultad)
        ['blk-data', 'blk-index', 'blk-prev', 'blk-nonce', 'blk-time'].forEach(id => {
            const n = el(id);
            if (!n) return;
            n.addEventListener('input', () => {
                recomputeHashAuto();   // recalcula hash y pinta estado
            });
        });



        // Timestamp inicial si est√° vac√≠o
        if (!el('blk-time').value) el('blk-time').value = nowISO();

        // Estado inicial coherente
        setVisual(false);
        recomputeHashAuto();

        // --- Minado ---
        let stopMining = false;
        el('btn-stop').addEventListener('click', () => {
            stopMining = true;
            showMining(false); // ocultar el indicador al parar
            // El estado visual se recalcular√° con recomputeHashAuto si cambias algo
        });

        el('btn-mine').addEventListener('click', async () => {
            stopMining = false;
            showMining(true);   // mostrar ‚ÄúMinando‚Ä¶‚Äù mientras trabaja

            const idx = Number(el('blk-index').value || 1);
            const ts = el('blk-time').value || nowISO();
            const prev = el('blk-prev').value || '0'.repeat(64);
            let nonce = Number(el('blk-nonce').value || 0);
            const d = getDifficulty();
            const target = '0'.repeat(d);

            // Importante: usar el texto crudo del textarea
            const dataRaw = el('blk-data').value ?? '';

            let attempts = 0;
            while (!stopMining) {
                const payload = JSON.stringify({
                    index: idx, timestamp: ts, data: dataRaw, previousHash: prev, nonce
                });
                const h = await sha256(payload);
                if (h.startsWith(target)) {
                    el('blk-nonce').value = nonce;
                    el('blk-hash').textContent = h;
                    setVisual(true);
                    showMining(false); // ocultar al terminar
                    return;
                }
                nonce++;
                attempts++;
                if (attempts % 500 === 0) await sleep(0);
            }

            // Si se detuvo, escondemos el indicador y refrescamos estado/hash actuales
            showMining(false);
            recomputeHashAuto();
        });




        // -------- UI: Blockchain --------
        async function renderChain() {
            const wrap = el('chain-view');
            wrap.innerHTML = '';
            for (const b of chain.chain) {
                const d = document.createElement('details');
                d.innerHTML = `<summary>#${b.index} ‚Äî ${b.hash.slice(0, 16)}‚Ä¶ <span class="badge" style="margin-left:6px">prev ${b.previousHash.slice(0, 10)}‚Ä¶</span></summary>
          <div class='list small'>
            <div><strong>Timestamp:</strong> ${b.timestamp}</div>
            <div><strong>Dificultad:</strong> ${b.difficulty}</div>
            <div><strong>Nonce:</strong> ${b.nonce}</div>
            <div><strong>TXs:</strong> <pre class='mono small'>${JSON.stringify(b.transactions, null, 2)}</pre></div>
          </div>`;
                wrap.appendChild(d);
            }
        }
        renderChain();

        el('btn-chain-new').addEventListener('click', async () => {
            chain = new Blockchain({ difficulty: Number(el('blk-diff').value) || 3, reward: Number(el('tx-reward').value) || 50 });
            await chain.createGenesis();
            el('chain-status').textContent = 'Estado: Nueva cadena';
            renderChain();
        });

        el('btn-chain-add').addEventListener('click', async () => {
            const b = readBlockInputs();
            // ajusta prevHash y dificultad a la cadena actual
            b.previousHash = chain.last.hash;
            b.difficulty = chain.difficulty;
            await b.mine();
            chain.chain.push(b);
            el('chain-status').textContent = 'Bloque a√±adido';
            renderChain();
        });

        el('btn-chain-validate').addEventListener('click', async () => {
            const ok = await chain.isValid();
            el('chain-status').textContent = ok ? '‚úÖ Cadena v√°lida' : '‚ùå Cadena inv√°lida';
        });

        el('btn-chain-tamper').addEventListener('click', async () => {
            if (chain.chain[1]) {
                chain.chain[1].transactions.push({ trucado: true, by: 'usuario' });
                chain.chain[1].hash = 'x'.repeat(64); // rompe el hash
                renderChain();
                el('chain-status').textContent = 'Se truc√≥ el bloque #1. Valida de nuevo para ver el fallo.';
            } else {
                el('chain-status').textContent = 'No hay bloque #1 a√∫n.';
            }
        });

        // -------- UI: Red distribuida --------
        function nodeCard(i) {
            const n = nodes[i];
            const top = n.last.hash.slice(0, 12) + '‚Ä¶';
            const div = document.createElement('div');
            div.className = 'node';
            div.innerHTML = `
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Nodo ${i + 1}</strong>
          <span class="badge">altura ${n.chain.length - 1}</span>
        </div>
        <div class="small muted">head: ${top}</div>
        <div class="hr"></div>
        <div class="list small">
          <label class="small muted">Minero de nodo</label>
          <input data-miner="${i}" value="${minerAddrs[i]}" />
          <button data-mine="${i}" class="good">Minar 1 bloque</button>
          <button data-show="${i}">Ver cadena</button>
          <div class="scroll"><pre class="mono small" id="node-view-${i}"></pre></div>
        </div>`;
            return div;
        }

        function renderNodes() {
            const wrap = el('nodes');
            wrap.innerHTML = '';
            nodes.forEach((_, i) => wrap.appendChild(nodeCard(i)));
            wrap.querySelectorAll('button[data-mine]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const i = Number(e.target.getAttribute('data-mine'));
                    const miner = wrap.querySelector(`input[data-miner="${i}"]`).value || minerAddrs[i];
                    nodes[i].reward = Number(el('tx-reward').value) || 50;
                    await nodes[i].addBlockFrom({ transactions: [], miner });
                    renderNodes();
                });
            });
            wrap.querySelectorAll('button[data-show]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const i = Number(e.target.getAttribute('data-show'));
                    const pre = el(`node-view-${i}`);
                    pre.textContent = JSON.stringify(nodes[i].chain.map(b => ({ i: b.index, hash: b.hash.slice(0, 16) + '‚Ä¶', prev: b.previousHash.slice(0, 10) + '‚Ä¶' })), null, 2);
                });
            });
            wrap.querySelectorAll('input[data-miner]').forEach(inp => {
                inp.addEventListener('change', (e) => {
                    const i = Number(e.target.getAttribute('data-miner'));
                    minerAddrs[i] = e.target.value;
                })
            })
        }
        renderNodes();

        el('btn-net-new').addEventListener('click', async () => {
            for (let i = 0; i < nodes.length; i++) { nodes[i] = new Blockchain({ difficulty: 3, reward: Number(el('tx-reward').value) || 50 }); await nodes[i].createGenesis(); }
            renderNodes();
        });

        el('btn-net-sync').addEventListener('click', async () => {
            // Consenso muy simple: elige la cadena v√°lida m√°s larga. Si hay empate, la primera.
            let best = nodes[0];
            for (const n of nodes) { if (n.chain.length > best.chain.length) best = n; }
            // Replicar
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i] !== best) { nodes[i].chain = JSON.parse(JSON.stringify(best.chain)); }
            }
            renderNodes();
        });

        // -------- UI: Coinbase & TX --------
        function refreshNodeSelect() {
            const sel = el('tx-node');
            sel.innerHTML = '';
            ['Nodo 1', 'Nodo 2', 'Nodo 3'].forEach((lab, i) => {
                const o = document.createElement('option'); o.value = String(i); o.textContent = lab; sel.appendChild(o);
            });
        }
        refreshNodeSelect();

        function renderMempool() {
            const n = nodes[Number(el('tx-node').value || 0)];
            el('mempool-view').textContent = JSON.stringify(n.mempool, null, 2);
        }

        function renderBalances() {
            const n = nodes[Number(el('tx-node').value || 0)];
            const bal = n.balances();
            const rows = Object.keys(bal).sort().map(k => `${k}: ${bal[k]}`);
            el('balances-view').textContent = rows.join('\n') || '(sin movimientos a√∫n)';
        }

        el('tx-node').addEventListener('change', () => { renderMempool(); renderBalances(); });

        el('btn-tx-add').addEventListener('click', () => {
            const n = nodes[Number(el('tx-node').value || 0)];
            const from = el('tx-from').value.trim();
            const to = el('tx-to').value.trim();
            const amount = Number(el('tx-amount').value || 0);
            if (!to || amount <= 0) { alert('Completa destinatario y cantidad>0'); return; }
            if (from && !n.canSpend(from, amount)) {
                alert('Saldo insuficiente en ' + from + ' (recuerda minar coinbase primero)');
                return;
            }
            n.mempool.push({ from, to, amount });
            renderMempool();
        });

        el('btn-mine-mempool').addEventListener('click', async () => {
            const idx = Number(el('tx-node').value || 0);
            const n = nodes[idx];
            n.reward = Number(el('tx-reward').value) || 50;
            const miner = el('miner-addr').value.trim() || 'miner' + (idx + 1);
            el('mine-coinbase-status').textContent = 'Minando‚Ä¶';
            const b = await n.addBlockFrom({ transactions: n.mempool, miner });
            el('mine-coinbase-status').textContent = 'Bloque #' + b.index + ' minado. Hash ' + b.hash.slice(0, 12) + '‚Ä¶';
            renderMempool();
            renderBalances();
            renderNodes();
        });

        el('btn-balances').addEventListener('click', () => { renderBalances(); });

        // Inicial
        renderMempool();
        renderBalances();
    </script>
</body>

</html>